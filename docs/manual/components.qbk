[/=============================================================================
    Copyright (C) 2015 Hartmut Kaiser

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]

[section:components Writing Components]

A component in __hpx__ is a C++ class which can be created remotely and for which
its member functions can be invoked remotely as well. The following sections
highlight how components can be defined, created, and used.

[//////////////////////////////////////////////////////////////////////////////]
[section:components_server Defining Components]

In order for a C++ class type to be managed remotely in __hpx__, the type must
be derived from the `hpx::components::simple_component_base` template type. We
call such C++ class types 'components'.

Note that the component type itself is passed as a template argument to the
base class.

    // header file some_component.hpp

    #include <hpx/include/components.hpp>

    namespace app
    {
        // Define a new component type 'some_component'
        struct some_component
          : hpx::components::simple_component_base<some_component>
        {
            // This member function is has to be invoked remotely
            int some_member_function(std::string s)
            {
                return boost::lexical_cast<int>(s);
            }

            // This will define the action type 'some_member_action' which
            // represents the member function 'some_member_function' of the
            // obect type 'some_component'.
            ``[macroref HPX_DEFINE_COMPONENT_ACTION `HPX_DEFINE_COMPONENT_ACTION`]``(some_component, some_member_function, some_member_action);
        };
    }

    // This will generate the necessary boiler-plate code for the action allowing
    // it to be invoked remotely. This declaration macro has to be placed in the
    // header file defining the component itself.
    //
    // Note: The second arguments to the macro below have to be systemwide-unique
    //       C++ identifiers
    //
    ``[macroref HPX_REGISTER_ACTION_DECLARATION `HPX_REGISTER_ACTION_DECLARATION`]``(app::some_component::some_member_action, some_component_some_action);

There is more boiler plate code which has to be placed into a
source file in order for the component to be usable. Every component type
requires to have macros placed into its source file, one for each component type
and one macro for each of the actions defined by the component type.

For instance:

    // source file some_component.cpp

    #include "some_component.hpp"

    // The following code generates all necessary boiler plate to enable the
    // remote creation of 'app::some_component' instances with 'hpx::new_<>()'
    //
    using some_component = app::some_component;
    using component_type = hpx::components::simple_component<some_component>;

    // Please note that the second argument to this macro must be a
    // (system-wide) unique C++-style identifier (without any namespaces)
    //
    ``[macroref HPX_REGISTER_COMPONENT `HPX_REGISTER_COMPONENT`]``(component_type, some_component);

    // The parameters for this macro have to be the same as used in the corresponding
    // HPX_REGISTER_ACTION_DECLARATION() macro invocation in the corresponding
    // header file.
    //
    // Please note that the second argument to this macro must be a
    // (system-wide) unique C++-style identifier (without any namespaces)
    //
    ``[macroref HPX_REGISTER_ACTION `HPX_REGISTER_ACTION`]``(app::some_component::some_member_action, some_component_some_action);

[endsect]

[//////////////////////////////////////////////////////////////////////////////]
[section:components_client Defining Client Side Representation Classes]

    #include <hpx/include/components.hpp>

    namespace app
    {
        // Define a client side representation type for the component type
        // 'some_component' defined in the previous section.
        struct some_component_client
          : hpx::components::client_base<some_component_client, some_component>
        {
            using base_type = hpx::components::client_base<
                    some_component_client, some_component>;

            some_component_client(hpx::future<hpx::id_type> && id)
              : base_type(std::move(id))
            {}

            hpx::future<int> some_member_function(std::string s)
            {
                some_component::some_member_action act;
                return hpx::async(act, get_gid());
            }
        };
    }

[endsect]

[//////////////////////////////////////////////////////////////////////////////]
[section:create_components Creating Component Instances]

Instances of defined component types can be created in two different ways. If
the component to create has a defined client side representation type, then this
can be used, otherwise use the server type.


[endsect]

[//////////////////////////////////////////////////////////////////////////////]
[section:use_components Using Component Instances]

[endsect]

[endsect] [/ Components]
