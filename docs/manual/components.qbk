[/=============================================================================
    Copyright (C) 2015 Hartmut Kaiser

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]

[section:components Writing Components]

A component in __hpx__ is a C++ class which can be created remotely and for which
its member function can be invoked remotely as well. The following sections
highlight how components can be defined, created, and used.

[//////////////////////////////////////////////////////////////////////////////]
[section:components_server Defining Components]

In order for a C++ class type to be managed remotely, the type must be derived
from the `hpx::components::simple_component_base` template type. Note that the
component type itself has to passed as a template argument to the base class.

    #include <hpx/include/components.hpp>

    namespace app
    {
        // Define a new component type 'some_component'
        struct some_component
          : hpx::components::simple_component_base<some_component>
        {
            // This member function should be invoked remotely
            int some_member_function(std::string s)
            {
                return boost::lexical_cast<int>(s);
            }

            // This will define the action type 'some_member_action' which
            // represents the member function 'some_member_function' of the
            // obect type 'some_component'.
            ``[macroref HPX_DEFINE_COMPONENT_ACTION `HPX_DEFINE_COMPONENT_ACTION`]``(some_component, some_member_function, some_member_action);
        };
    }

    // This will generate the necessary boiler-plate code for the action allowing
    // it to be invoked remotely. This declaration macro has to be placed in the
    // header file defining the component itself.
    //
    // Note: The second arguments to the macro below have to be systemwide-unique
    //       C++ identifiers
    ``[macroref HPX_REGISTER_ACTION_DECLARATION `HPX_REGISTER_ACTION_DECLARATION`]``(app::some_component::some_member_action, some_component_some_action);

[endsect]

[//////////////////////////////////////////////////////////////////////////////]
[section:components_client Defining Client Side Representation Classes]

    #include <hpx/include/components.hpp>

    namespace app
    {
        // Define a client side representation type for the component type
        // 'some_component' defined in the previous section.
        struct some_component_client
          : hpx::components::client_base<some_component_client, some_component>
        {
            using base_type = hpx::components::client_base<
                    some_component_client, some_component>;

            some_component_client(hpx::future<hpx::id_type> && id)
              : base_type(std::move(id))
            {}

            hpx::future<int> some_member_function(std::string s)
            {
                some_component::some_member_action act;
                return hpx::async(act, get_gid());
            }
        };
    }

[endsect]

[//////////////////////////////////////////////////////////////////////////////]
[section:create_components Creating Component Instances]

Instances of defined component types can be created in two different ways. If
the component to create has a defined client side representation type, then this
can be used, otherwise use the server type.


[endsect]

[//////////////////////////////////////////////////////////////////////////////]
[section:use_components Using Component Instances]

[endsect]

[endsect] [/ Components]
