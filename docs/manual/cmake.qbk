[/==============================================================================
    Copyright (C) 2007-2013 Hartmut Kaiser
    Copyright (C) 2013-2014 Thomas Heller

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]

[/
[/////////////////////////////////////////////////////////////////////////////]

[/////////////////////////////////////////////////////////////////////////////]
[section:existing_apps How to Use __hpx__ with CMake]

[/
Having your application work with __hpx__ is unfortunately not as simple as just
linking against it. However it can be rather straightforward or rather complex
based on the type of application that is trying to be integrated. The complexity
derives from the overall design of the application. If the application was
designed to be parallel, then integrating should be relatively straightforward.
However __hpx__ is not some magic wand that will make your application work in
parallel. Applications that are serial or that rely too heavily on global
variables will have a more difficult time in integrating. Most parallel
applications have already identified the sections of code that do the most
work and have abstracted them out to use the parallel library of their choice.

One of the big advantages of __hpx__ is the concept of moving work to data.
Data-heavy applications can use components to create remote objects that
encapsulate that data, and call methods on these component-objects.
Computation-heavy applications do not care so much about moving work to data,
but instead try to get as much parallel computation done as possible. __hpx__
futures provide a nice tool for accomplishing this. Using futures, one can
set up a lot of work to be done, fire it off and wait for them to be finished.
__hpx__ takes care of creating the threads, moving the work across node
boundaries, and making sure the calling thread suspends when it wants the
value from a future that is still executing. A lot of boring code that you do not
need to write. The one caveat is that for any function you wrap with a
future, any parameters of those functions need to be serializable. This can be
a rather complicated procedure if the data structures are complex.
__hpx__ uses __boost_serialization__ for the serialization of the data to be
used in futures. That really is the hardest part, because once the serialization
functions are completed, you can use futures anywhere in your code. If you
plan on only running on an SMP machine, then __hpx__ never calls the
serialization functions and they may be blank (but the signatures are still
required).

The next stumbling block to integrating __hpx__ is having it actually link
against your program. If your application uses a CMake build system, you can
set the CMake Module Path to the path where __hpx__ has the `FindHPX.cmake`
module. Here is a code snippet demonstrating this.
/]

In Addition to the pkg-config support discussed on the previous pages, __hpx__
comes with full CMake support. In order to integrate __hpx__ into your existing,
or new CMakeLists.txt you can include `FindHPX.cmake`. Following is the Hello
World component example using CMake instead of pkg-config.

Let's revisit what we have. We have three files which compose our example
application:

* `hello_world_component.hpp`
* `hello_world_component.cpp`
* `hello_world_client.hpp`

The basic structure to include __hpx__ into your CMakeLists.txt is shown here:
[teletype]
``
    # Require a recent version of cmake
    cmake_minimum_required(VERSION 2.8.4 FATAL_ERROR)

    # This project is C++ based.
    project(your_app CXX)

    # This adds the __hpx__ cmake configuration directory to the search path.
    set(CMAKE_MODULE_PATH
        ${HPX_ROOT}/share/cmake-${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}/Modules)

    # Instruct cmake to find the __hpx__ settings
    find_package(HPX)

    include_directories(${HPX_INCLUDE_DIR})
    link_directories(${HPX_LIBRARY_DIR})
``

This cmake script assumes that the location of the __hpx__ installation is set
as the value of HPX_ROOT which is best done by passing it on the command line
while invoking cmake:

``
    cmake -DHPX_ROOT=<HPX installations directory> ...
``

The last two lines in the snippet above sets the appropriate include and link
directories.

In order to add the __hpx__ component we use the `add_hpx_component` macro and
add it to the `CMakeLists.txt` file:


[/
Now all you
have to do is type `make` and the application should build using the __hpx__
installation you specified.
]

[note
    `FindHPX.cmake` makes adjustments various cmake internal settings such as
    compiler and linker flags. This is needed to ensure maximal compatibility
    between your application and the __hpx__ version you are using.
    The `add_hpx_executable` and `add_hpx_component` additionally add the proper
    libraries to link against.
]

[/
Those two things, the serialization and actually integrating with __hpx__,
are the biggest stumbling blocks that you should encountered when trying to
integrate your application with __hpx__. For an idea on how to integrate __hpx__
constructs into your application, you should take a look at some of the examples
that __hpx__ includes.
]

[endsect] [/ Integrating __hpx__ into existing applications]

[endsect] [/ Building __hpx__ with CMake]
]

