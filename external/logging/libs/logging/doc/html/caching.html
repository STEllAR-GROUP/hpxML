<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Boost Logging Library v2: Caching messages before logs are initialized</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
  </ul>
</div>
<h1><a class="anchor" name="caching">Caching messages before logs are initialized</a></h1><ul>
<li><a class="el" href="caching.html#caching_why">Caching - why is it needed?</a></li><li><a class="el" href="caching.html#caching_BOOST_LOG_BEFORE_INIT_LOG_ALL">Cache messages before logs are initialized regardless of their filter (BOOST_LOG_BEFORE_INIT_LOG_ALL)</a></li><li><a class="el" href="caching.html#caching_BOOST_LOG_BEFORE_INIT_CACHE_FILTER">Cache messages before logs are initialized/ cache their filter as well (BOOST_LOG_BEFORE_INIT_CACHE_FILTER)</a><ul>
<li><a class="el" href="caching.html#caching_BOOST_LOG_BEFORE_INIT_CACHE_FILTER_the_catch">BOOST_LOG_BEFORE_INIT_CACHE_FILTER - the catch...</a></li></ul>
</li><li><a class="el" href="caching.html#caching_BOOST_LOG_BEFORE_INIT_IGNORE_BEFORE_INIT">Ignore all messages before mark_as_initialized (BOOST_LOG_BEFORE_INIT_IGNORE_BEFORE_INIT)</a></li></ul>
<h2><a class="anchor" name="caching_why">
Caching - why is it needed?</a></h2>
Logging is all fine and dandy, but what if you do some logging before the actual logs are initialized? It's quite easy to end up doing this:<ul>
<li>usually you initialize logs somewhere within your <code>main()</code> </li><li>as applications grow, you'll have global/static variables</li><li>you'll do logging from the body of the global/static variable's constructors<ul>
<li>direcly (from a constructor)</li><li>indirectly (from some constructor you call a function, which calls a function... which in turn does some <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a>)</li></ul>
</li></ul>
<p>
You could even run into more complicated scenarios, where you create other threads, which, until you initialize your logs, do some <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a>. It's good practice to log a thread's begin and end, for instance.<p>
Even though you think this'll never happen to you, usage of singletons and other static variables is quite common, so better to guard against it.<p>
One solution would be for the library to rely on an external function, like <code>void boost::logging::init_logs()</code>, and have your application have to define it, and it its body, initialize the logs. The library would then make sure the <code>init_logs()</code> is called before any log is used.<p>
There are several problems with this solution:<ul>
<li>logs could be used too soon before you have all the needed data to initialize them (for instance, some could depend on command line arguments)</li><li>before any log is used, I would need to make sure <code>init_logs()</code> has been called - thus, for each log usage, I would need to check if init_logs has been called or not - not very efficient</li><li>within init_logs() I might end up using logs, thus ending in an infinite loop (log needs init_logs(), which uses log)</li><li>you would not have any control over when <code>init_logs()</code> is called - what if they need some context information - they wouldn't have any context do rely on</li><li>depending on your application, some logs could only be initialized later than others</li><li>if your application has several modules, assume each module has its own log. Thus, each module should be able to initialize its own log when the module is initialized</li></ul>
<p>
Thus, I came up with a caching mechanism. You can choose to:<ul>
<li>Cache messages that are written before logs are initialized. For each logged message, you will also cache its corresponding <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> (so that if, when initializing the logs, a certain <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> is turned off, that message won't be logged)</li><li>Cache messages that are written before logs are initialized. When logs are initialized, all these cached messages are logged</li><li>Ignore messages that are written before the logs are initialized</li></ul>
<p>
<b>By default, for each log, cache is turned on. To turn cache off (mark the log as initialized), just call <code>mark_as_initialized()</code> on it. You'll see that I'm doing this on all examples that come with the library.</b><h2><a class="anchor" name="caching_BOOST_LOG_BEFORE_INIT_LOG_ALL">
Cache messages before logs are initialized regardless of their filter (BOOST_LOG_BEFORE_INIT_LOG_ALL)</a></h2>
This case is the <b>default</b>. When cache is on, all messages are cached, regardless of their <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> (as if all filters are turned on). Then, when cache is marked as initialized, all cached messages are logged.<p>
If you want to force this setting, make sure you define the <code>BOOST_LOG_BEFORE_INIT_LOG_ALL</code> globally (it's on by default anyway).<p>
<div class="fragment"><pre class="fragment">...
#define L_ BOOST_LOG_USE_LOG_IF_FILTER(g_l(), g_log_filter()-&gt;is_enabled() ) 
...

L_ &lt;&lt; <span class="stringliteral">"this message will be logged, even if filter will be turned off"</span>;
g_log_filter()-&gt;set_enabled(<span class="keyword">false</span>);
g_l()-&gt;mark_as_initialized();
</pre></div><p>
<br>
 <h2><a class="anchor" name="caching_BOOST_LOG_BEFORE_INIT_CACHE_FILTER">
Cache messages before logs are initialized/ cache their filter as well (BOOST_LOG_BEFORE_INIT_CACHE_FILTER)</a></h2>
It's a bit inefficient (after invoking the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a>, it will always ask if cache is on or off). Also, it increases the application's size a bit - for each log statement, I will generate a callback that I can call later to see if the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> is still turned on or off.<p>
<div class="fragment"><pre class="fragment">...
#define L_ BOOST_LOG_USE_LOG_IF_FILTER(g_l(), g_log_filter()-&gt;is_enabled() ) 
...

L_ &lt;&lt; <span class="stringliteral">"this message will not be logged"</span>;
g_log_filter()-&gt;set_enabled(<span class="keyword">false</span>);
g_l()-&gt;mark_as_initialized();
</pre></div><p>
If you do want to use this setting, make sure you define the <code>BOOST_LOG_BEFORE_INIT_CACHE_FILTER</code> globally.<h3><a class="anchor" name="caching_BOOST_LOG_BEFORE_INIT_CACHE_FILTER_the_catch">
BOOST_LOG_BEFORE_INIT_CACHE_FILTER - the catch...</a></h3>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If you don't want to cache the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a>, just skip to the <a class="el" href="caching.html#caching_BOOST_LOG_BEFORE_INIT_IGNORE_BEFORE_INIT">next section</a>.</dd></dl>
If you cache the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> as well, in order for the caching process to work, all the parameters you pass to the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> need to be:<ul>
<li>either compile-time constants, or</li><li>global values</li></ul>
<p>
Assume you have a <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> with a <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> based on levels: <div class="fragment"><pre class="fragment"><span class="comment">// for exposition only - normally you'd use BOOST_LOG_USE_LOG_IF_LEVEL</span>
<span class="preprocessor">#define L_(lvl) BOOST_LOG_USE_LOG_IF_FILTER(g_l(), g_log_level()-&gt;is_enabled( lvl ) )</span>
</pre></div><p>
If you cache the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a>, the expression <code>g_log_level()-&gt;is_enabled( lvl )</code> needs to be recomputed at a later time (when the log is marked as initialized, and all messages that were cached, are logged). Thus, all parameters that are passed to the your L_ macro need to be either compile-time constants or global values. Otherwise, a compile-time error will be issued:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> f() {
  boost::logging::level lvl = ...;
  <span class="comment">// will generate a compile-time error : using a local variable as param</span>
  L_(lvl) &lt;&lt; <span class="stringliteral">"wish it could work"</span>;
}
</pre></div><p>
Normally you should not care about this, since whatever you pass to your <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a> macros should indeed be constant.<p>
<br>
 <h2><a class="anchor" name="caching_BOOST_LOG_BEFORE_INIT_IGNORE_BEFORE_INIT">
Ignore all messages before mark_as_initialized (BOOST_LOG_BEFORE_INIT_IGNORE_BEFORE_INIT)</a></h2>
In the last case, all messages before <code>mark_as_initialized()</code> are ignored.<p>
If you do want to use this setting, make sure you define the <code>BOOST_LOG_BEFORE_INIT_IGNORE_BEFORE_INIT</code> globally.<p>
<div class="fragment"><pre class="fragment">...
#define L_ BOOST_LOG_USE_LOG_IF_FILTER(g_l(), g_log_filter()-&gt;is_enabled() ) 
...

L_ &lt;&lt; <span class="stringliteral">"this message will NOT be logged"</span>;
g_l()-&gt;mark_as_initialized();
</pre></div> <hr>
<br>
<small> Copyright <a href="http://www.torjo.com">John Torjo</a> &copy; 2007
</small> <br>

<small> Have a question/ suggestion/ comment? Send me <a href="http://www.torjo.com/contact.html">feedback</a>
</small> 

</body>
</html>
