<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Boost Logging Library v2: Known Issues</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
  </ul>
</div>
<h1><a class="anchor" name="known_issues">Known Issues</a></h1><ul>
<li><a class="el" href="known_issues.html#known_issue_modifying_manipulator">Modifying a manipulator while it's used</a></li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This section assumes you're quite familiar with Boost Logging Lib v2, thus the concepts used here are not explained.</dd></dl>
<br>
 <h2><a class="anchor" name="known_issue_modifying_manipulator">
Modifying a manipulator while it's used</a></h2>
<br>
 <h3><a class="anchor" name="known_issue_modifying_manipulator_code">
Sample code</a></h3>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#define L_(lvl) BOOST_LOG_USE_LOG_IF_LEVEL(g_l(), g_log_level(), lvl )</span>
<span class="preprocessor"></span>
<a class="code" href="namespaceboost_1_1logging_1_1destination.html#1bdbe209347a0ab6c4f0f472ac0ddbe0" title="stream_t with default values. See stream_t">destination::stream</a> out(std::cout);
g_l()-&gt;writer().add_destination(out);
...


<span class="comment">// Thread 1</span>
out.stream(std::cerr);

<span class="comment">// Thread 2</span>
L_ &lt;&lt; <span class="stringliteral">"whatever"</span>;
</pre></div><p>
<br>
 <h3><a class="anchor" name="known_issue_modifying_manipulator_resolution">
Resolution</a></h3>
If the above code executes concurrently on Threads 1 and 2, we could get in trouble.<p>
This happens because the thread-safe access is guaranteed :<ul>
<li>only if you specify it - when defining the <a class="el" href="namespaceboost_1_1logging_1_1writer.html" title="Classes that write the message, once it&#39;s been gathered.">writer</a> (see <a class="el" href="namespaceboost_1_1logging_1_1scenario_1_1usage.html">scenario based on usage</a> and <a class="el" href="structboost_1_1logging_1_1logger__format__write.html" title="Makes it easier to use a logger with format_write class.">logger_format_write</a>)</li><li>it's guaranteed only for <em>adding and deleting</em> manipulators, not for modifying manipulators.</li></ul>
<p>
If we were to allow modifying manipulators, we'd have to:<ol type=1>
<li>either allow a way to pause()/resume() the logger(s) that use a given <a class="el" href="namespaceboost_1_1logging_1_1manipulator.html" title="Manipulators = Formatters and/or destinations.">manipulator</a> or</li><li>allow thread-safe access to the <a class="el" href="namespaceboost_1_1logging_1_1manipulator.html" title="Manipulators = Formatters and/or destinations.">manipulator</a> objects (meaning each public method would use a mutex, and keep it locked)</li></ol>
<p>
In case of the former, pitfalls:<ul>
<li>When modifying a <a class="el" href="namespaceboost_1_1logging_1_1manipulator.html" title="Manipulators = Formatters and/or destinations.">manipulator</a>, you'd need to pause() all loggers that use it. You need to know them.</li><li>This pause()/resume() mechanism will slow the <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a> process a bit</li><li>This will mean tight coupling between the <a class="el" href="namespaceboost_1_1logging_1_1writer.html" title="Classes that write the message, once it&#39;s been gathered.">writer</a> and its member data.</li><li>In case a lot of <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a> happens while a <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> is paused, could cause either a lot of caching, or a performance hit (a lot of threads would have to wait for the resume() to happen)</li></ul>
<p>
In case of the latter, pitfalls:<ul>
<li>This will incur a big speed penalty - each time you invoke operator() on the <a class="el" href="namespaceboost_1_1logging_1_1manipulator.html" title="Manipulators = Formatters and/or destinations.">manipulator</a>, will involve a mutex lock/unlock</li><li>The more manipulators a <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> uses, the more mutex lock/unlocks will happen. Thus, the speed penalty will be even bigger.</li></ul>
<p>
As a side-note, if I were a well known company, I'd just say "This behavior is by design".<p>
<br>
 <h3><a class="anchor" name="known_issue_modifying_manipulator_when">
When does it happen?</a></h3>
I would say seldom. This can happen to you only if you want to modify loggers <em>after</em> you've initialized - thus, while you're <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a>.<p>
The usual <a class="el" href="namespaceboost_1_1logging_1_1scenario.html" title="Use this when you have a specific scenario, and want the best logger/filter classes...">scenario</a> is :<ul>
<li>you initialize Logging once, at beginning of program</li><li>you perform logging (you don't modify the loggers once they've been initialized)</li></ul>
<p>
In the above <a class="el" href="namespaceboost_1_1logging_1_1scenario.html" title="Use this when you have a specific scenario, and want the best logger/filter classes...">scenario</a>, this issue will never happen. However, if you do run into it, see <a class="el" href="known_issues.html#known_issue_modifying_manipulator_workaround">below</a>.<p>
<br>
 <h3><a class="anchor" name="known_issue_modifying_manipulator_workaround">
Solution</a></h3>
The solution is dead-simple. Just delete this manipulator, create one of the same type, modify that one, and then add it to your logger(s). In the original <a class="el" href="known_issues.html#known_issue_modifying_manipulator_code">scenario</a>, you'd do this:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#define L_(lvl) BOOST_LOG_USE_LOG_IF_LEVEL(g_l(), g_log_level(), lvl )</span>
<span class="preprocessor"></span>
<a class="code" href="namespaceboost_1_1logging_1_1destination.html#1bdbe209347a0ab6c4f0f472ac0ddbe0" title="stream_t with default values. See stream_t">destination::stream</a> out(std::cout);
g_l()-&gt;writer().add_destination(out);
...


<span class="comment">// Thread 1</span>
destination::stream out2(std::cerr);
g_l()-&gt;writer().del_destination(out);
g_l()-&gt;writer().add_destination(out2);

<span class="comment">// Thread 2 - all good</span>
L_ &lt;&lt; <span class="stringliteral">"whatever"</span>;
</pre></div> <hr>
<br>
<small> Copyright <a href="http://www.torjo.com">John Torjo</a> &copy; 2007
</small> <br>

<small> Have a question/ suggestion/ comment? Send me <a href="http://www.torjo.com/contact.html">feedback</a>
</small> 

</body>
</html>
