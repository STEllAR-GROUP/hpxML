<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Boost Logging Library v2: Using the logger(s)/filter(s) after they&#39;ve been destroyed</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
  </ul>
</div>
<h1><a class="anchor" name="after_destruction">Using the logger(s)/filter(s) after they've been destroyed</a></h1><ul>
<li><a class="el" href="after_destruction.html#after_destruction_can_happen">Can this happen?</a></li><li><a class="el" href="after_destruction.html#after_destruction_avoid">Avoiding the issue: making sure it never happens</a></li><li><a class="el" href="after_destruction.html#after_destruction_solution">The solution</a></li></ul>
<p>
<br>
<br>
 <h2><a class="anchor" name="after_destruction_can_happen">
Can this happen?</a></h2>
The short answer : yes. How? The order of inialization between translation units is not defined, thus the same applies for destruction. The following can happen:<ul>
<li>a global object is constructed <em>before</em> a <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a></li><li>thus, it will be destroyed <em>after</em> the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a></li><li>if in its destructor it tries to use the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a>, there we go - <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> is used after it's been destroyed.</li></ul>
<p>
<br>
<br>
 <h2><a class="anchor" name="after_destruction_avoid">
Avoiding the issue: making sure it never happens</a></h2>
Many thanks to Daniel Kruger for helping me with this:<ul>
<li><a href="http://groups.google.ro/group/comp.lang.c++.moderated/tree/browse_frm/thread/17987673016b2098/d4c6bdcdca1e8fe9?hl=ro&rnum=1&_done=%2Fgroup%2Fcomp.lang.c%2B%2B.moderated%2Fbrowse_frm%2Fthread%2F17987673016b2098%3Fhl%3Dro%26#doc_aa38c20511f81615">http://groups.google.ro/group/comp.lang.c++.moderated/tree/browse_frm/thread/17987673016b2098/d4c6bdcdca1e8fe9?hl=ro&amp;rnum=1&amp;_done=%2Fgroup%2Fcomp.lang.c%2B%2B.moderated%2Fbrowse_frm%2Fthread%2F17987673016b2098%3Fhl%3Dro%26#doc_aa38c20511f81615</a></li><li><a href="http://groups.google.ro/group/comp.lang.c++.moderated/tree/browse_frm/thread/17987673016b2098/d4c6bdcdca1e8fe9?hl=ro&rnum=1&_done=%2Fgroup%2Fcomp.lang.c%2B%2B.moderated%2Fbrowse_frm%2Fthread%2F17987673016b2098%3Fhl%3Dro%26#doc_f506c2b42f21dad9">http://groups.google.ro/group/comp.lang.c++.moderated/tree/browse_frm/thread/17987673016b2098/d4c6bdcdca1e8fe9?hl=ro&amp;rnum=1&amp;_done=%2Fgroup%2Fcomp.lang.c%2B%2B.moderated%2Fbrowse_frm%2Fthread%2F17987673016b2098%3Fhl%3Dro%26#doc_f506c2b42f21dad9</a></li></ul>
<p>
The way to handle this is: since we can't handle initialization between translation units, we can handle initialization within the same translation unit. In the same translation unit, if we have: <div class="fragment"><pre class="fragment"><span class="keyword">static</span> A a;
<span class="keyword">static</span> B b;
</pre></div><p>
... we're guaranteed <code>a</code> is initialized before <code>b</code>. In other words, if in a translation unit <code>a</code> is defined before <code>b</code>, <code>a</code> will be initialized before <code>b</code>.<p>
Apply this to our problem:<ul>
<li>we just need some object that will reference the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a>, to be defined before the global object that might end up using the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> in its destructor<ul>
<li>note: referencing the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> will imply it gets constructed first</li></ul>
</li><li>this way, the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> will be created before the global object, and thus be destroyed after it</li></ul>
<p>
In every translation unit that has a global object that might end up using logger(s) on its destructor, we need to create some object that will reference those loggers before the global object's definition.<p>
Therefore, the amazing solution:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// exposistion only</span>
<span class="preprocessor">#define BOOST_DECLARE_LOG(name,type) type* name (); \</span>
<span class="preprocessor">    namespace { boost::logging::ensure_early_log_creation ensure_log_is_created_before_main ## name ( * name () ); }</span>
</pre></div><p>
When declaring the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a>, we create a dummy static - in each translation unit -, that uses the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a>; this will ensure the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> is created before the global object that will use it.<h2><a class="anchor" name="after_destruction_solution">
The solution</a></h2>
All you need to do is :<ul>
<li>#include the header file that declares the logs in all translation units that have global objects that could log from their destructor.</li><li>of course, to be sure, you could #include that header in all translation units :)</li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This applies to filters as well. </dd></dl>
<hr>
<br>
<small> Copyright <a href="http://www.torjo.com">John Torjo</a> &copy; 2007
</small> <br>

<small> Have a question/ suggestion/ comment? Send me <a href="http://www.torjo.com/contact.html">feedback</a>
</small> 

</body>
</html>
