<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Boost Logging Library v2: Getting started - the Fast &amp; Furious way...</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
  </ul>
</div>
<h1><a class="anchor" name="getting_started">Getting started - the Fast &amp; Furious way...</a></h1><ul>
<li><a class="el" href="getting_started.html#getting_started_basics">The basics</a></li><li><a class="el" href="getting_started.html#getting_started_code">Structuring your code</a></li><li><a class="el" href="getting_started.html#getting_started_example_no_levels">Example 1 : Have one Named Writer, No levels</a></li><li><a class="el" href="getting_started.html#getting_started_example_use_levels">Example 2 : Have one Named Writer , Use Levels</a></li><li><a class="el" href="getting_started.html#getting_started_other_examples">Other examples...</a></li></ul>
<p>
So, you don't have time to spend (at least not right now), to read the <a class="el" href="index.html#log_tutorial">tutorial</a>, but still want to use the Boost Logging Lib.<p>
<br>
<br>
 <h2><a class="anchor" name="getting_started_basics">
The basics</a></h2>
Here are the quick facts:<ul>
<li>We use the folloging concepts:<ul>
<li><a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> : the class that does the <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a>. You can have several <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> objects in your code, but usually one will suffice.<ul>
<li><a class="el" href="namespaceboost_1_1logging_1_1writer.html" title="Classes that write the message, once it&#39;s been gathered.">writer</a> : an object, part of the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a>, that is in charge of writing the message</li></ul>
</li><li><a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> : the class that does the filtering - that is, it knows if a message should be logged or not</li></ul>
</li></ul>
<p>
There are several <a class="el" href="namespaceboost_1_1logging_1_1writer.html">writers</a>. The most common uses the concept of formatters and destinations:<ul>
<li><a class="el" href="namespaceboost_1_1logging_1_1formatter.html" title="Formatter is a manipulator. It allows you to format the message before writing it...">formatter</a> : formats the message before writing it (for instance, by prepending time to it, an index, etc.)</li><li><a class="el" href="namespaceboost_1_1logging_1_1destination.html" title="Destination is a manipulator. It contains a place where the message, after being...">destination</a> : represents a place where the message is to be written to (like, console, a file, debug window, etc.)</li></ul>
<p>
Once you have a writer, you can add several formatters and/or destinations. The writer object knows how to call them. The common (and default) one calls them like this:<ul>
<li>first, all formatters (in the order they were added)</li><li>second, all destinations (in the order they were added)</li></ul>
<p>
The easiest writer is the <a class="el" href="structboost_1_1logging_1_1writer_1_1named__write.html">Named Writer</a>. It's an easy interface to using formatters and destinations. In other words, you set <a class="el" href="structboost_1_1logging_1_1writer_1_1named__write.html#format_string_syntax">a format string</a> and <a class="el" href="structboost_1_1logging_1_1writer_1_1named__write.html#dest_string_syntax">a destination string</a>.<p>
<br>
<br>
 <h2><a class="anchor" name="getting_started_code">
Structuring your code</a></h2>
You'll use macros to:<ul>
<li>declare and define the filters and loggers</li><li>do logging.</li></ul>
<p>
You should structure your code like this:<ul>
<li>have a header file, in which you <code>#include</code> the Boost Logging Lib forward classes, and you declare your loggers and filters</li><li>have a source file, in which you define your loggers and filters, and eventually initialize them</li><li>in the rest of the code, when you intend to do logging, just include the above header file</li></ul>
<p>
<br>
<br>
 <h2><a class="anchor" name="getting_started_example_no_levels">
Example 1 : Have one Named Writer, No levels</a></h2>
Assume you want one <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> and one <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> - the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> is a simple <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> that can only be turned on/off (the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> is not thread-safe). <br>
 This is something you can copy-paste into your program.<p>
<div class="fragment"><pre class="fragment">
<span class="comment">// my_app_log.h - DECLARE your loggers &amp; filters here</span>
<span class="preprocessor">#ifndef my_app_LOG_H_header</span>
<span class="preprocessor"></span><span class="preprocessor">#define my_app_LOG_H_header</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &lt;boost/logging/format/named_write_fwd.hpp&gt;</span>
<span class="comment">// #include &lt;boost/logging/writer/on_dedicated_thread.hpp&gt; // uncomment if you want to do logging on a dedicated thread</span>

<span class="keyword">namespace </span>bl = boost::logging;
<span class="keyword">typedef</span> <a class="code" href="structboost_1_1logging_1_1named__logger.html" title="named_logger&amp;lt;...&amp;gt;type finds a logger that uses writer::named_write&amp;lt;&amp;gt;...">bl::named_logger&lt;&gt;::type</a> logger_type;
<span class="keyword">typedef</span> <a class="code" href="structboost_1_1logging_1_1filter_1_1no__ts.html" title="Manages is_enabled/set_enabled in a non-thread-safe way.">bl::filter::no_ts</a> filter_type;

BOOST_DECLARE_LOG_FILTER(g_l_filter, filter_type)
BOOST_DECLARE_LOG(g_l, logger_type)

<span class="preprocessor">#define L_ BOOST_LOG_USE_LOG_IF_FILTER( g_l(), g_log_filter()-&gt;is_enabled() ) </span>
<span class="preprocessor"></span>
<span class="comment">// initialize thy logs..</span>
<span class="keywordtype">void</span> init_logs();

<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">// my_app_log.cpp - DEFINE your loggers &amp; filters here</span>
<span class="preprocessor">#include "my_app_log.h"</span>
<span class="preprocessor">#include &lt;boost/logging/format/named_write.hpp&gt;</span>

BOOST_DEFINE_LOG_FILTER(g_log_filter, filter_type ) 
BOOST_DEFINE_LOG(g_l, logger_type) 


<span class="keywordtype">void</span> init_logs() {
    <span class="comment">// formatting    : time [idx] message \n</span>
    <span class="comment">// destinations  : console, file "out.txt" and debug window</span>
    g_l()-&gt;writer().write(<span class="stringliteral">"%time%($hh:$mm.$ss.$mili) [%idx%] |\n"</span>, <span class="stringliteral">"cout file(out.txt) debug"</span>);
    g_l()-&gt;mark_as_initialized();
}

<span class="keywordtype">void</span> use_logger() {
    <span class="keywordtype">int</span> i = 1;
    L_ &lt;&lt; <span class="stringliteral">"this is a simple message "</span> &lt;&lt; i;
    std::string hello = <span class="stringliteral">"hello"</span>;
    L_ &lt;&lt; hello &lt;&lt; <span class="stringliteral">" world"</span>;
}
</pre></div><p>
<br>
<br>
 <h2><a class="anchor" name="getting_started_example_use_levels">
Example 2 : Have one Named Writer , Use Levels</a></h2>
Assume you want one <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> and one <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> - the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> is a based on levels (the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> is not thread-safe). <br>
 This is something you can copy-paste into your program.<p>
<div class="fragment"><pre class="fragment">
<span class="comment">// my_app_log.h - DECLARE your loggers &amp; filters here</span>
<span class="preprocessor">#ifndef my_app_LOG_H_header</span>
<span class="preprocessor"></span><span class="preprocessor">#define my_app_LOG_H_header</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &lt;boost/logging/format/named_write_fwd.hpp&gt;</span>
<span class="comment">// #include &lt;boost/logging/writer/on_dedicated_thread.hpp&gt; // uncomment if you want to do logging on a dedicated thread</span>

<span class="keyword">namespace </span>bl = boost::logging;
<span class="keyword">typedef</span> <a class="code" href="structboost_1_1logging_1_1named__logger.html" title="named_logger&amp;lt;...&amp;gt;type finds a logger that uses writer::named_write&amp;lt;&amp;gt;...">bl::named_logger&lt;&gt;::type</a> logger_type;
<span class="keyword">typedef</span> bl::level::holder filter_type;

BOOST_DECLARE_LOG_FILTER(g_l_level, filter_type)
BOOST_DECLARE_LOG(g_l, logger_type)

<span class="preprocessor">#define L_(lvl) BOOST_LOG_USE_LOG_IF_LEVEL(g_l(), g_l_level(), lvl )</span>
<span class="preprocessor"></span>
<span class="comment">// initialize thy logs..</span>
<span class="keywordtype">void</span> init_logs();

<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">// my_app_log.cpp - DEFINE your loggers &amp; filters here</span>
<span class="preprocessor">#include "my_app_log.h"</span>
<span class="preprocessor">#include &lt;boost/logging/format/named_write.hpp&gt;</span>

BOOST_DEFINE_LOG_FILTER(g_l_level, filter_type ) 
BOOST_DEFINE_LOG(g_l, logger_type) 


<span class="keywordtype">void</span> init_logs() {
    <span class="comment">// formatting    : time [idx] message \n</span>
    <span class="comment">// destinations  : console, file "out.txt" and debug window</span>
    g_l()-&gt;writer().write(<span class="stringliteral">"%time%($hh:$mm.$ss.$mili) [%idx%] |\n"</span>, <span class="stringliteral">"cout file(out.txt) debug"</span>);
    g_l()-&gt;mark_as_initialized();
}

<span class="keywordtype">void</span> use_logger() {
    <span class="keywordtype">int</span> i = 1;
    L_(debug) &lt;&lt; <span class="stringliteral">"this is a simple message "</span> &lt;&lt; i;
    std::string hello = <span class="stringliteral">"hello"</span>;
    L_(info) &lt;&lt; hello &lt;&lt; <span class="stringliteral">" world"</span>;
}
</pre></div><h2><a class="anchor" name="getting_started_other_examples">
Other examples...</a></h2>
Yup, we have <a class="el" href="common_scenarios.html">other examples</a> as well. We also have a <a class="el" href="starter_project.html">starter project</a>. <hr>
<br>
<small> Copyright <a href="http://www.torjo.com">John Torjo</a> &copy; 2007
</small> <br>

<small> Have a question/ suggestion/ comment? Send me <a href="http://www.torjo.com/contact.html">feedback</a>
</small> 

</body>
</html>
