<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Boost Logging Library v2: boost::logging Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="namespaces.html"><span>Namespace List</span></a></li>
    <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<b>boost</b>::<a class="el" href="namespaceboost_1_1logging.html">logging</a></div>
<h1>boost::logging Namespace Reference</h1>Root namespace. All the <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a> lib is contained in this namespace, or sub-namespaces of this one.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1logging_1_1after__being__destroyed__defer__to__function.html">after_being_destroyed_defer_to_function</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1logging_1_1dump__default__levels.html">dump_default_levels</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1logging_1_1dump__level.html">dump_level</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1logging_1_1named__logger.html">named_logger</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structboost_1_1logging_1_1named__logger.html" title="named_logger&lt;...&gt;type finds a logger that uses writer::named_write&lt;&gt;...">named_logger</a>&lt;...&gt;type finds a <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> that uses <a class="el" href="structboost_1_1logging_1_1writer_1_1named__write.html">writer::named_write</a>&lt;&gt; "Named Formatters and Destinations"  <a href="structboost_1_1logging_1_1named__logger.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1logging_1_1logger__holder.html">logger_holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows using a log without knowing its full type yet. Even if the log is not fully <b>defined</b>, you can still use it.  <a href="structboost_1_1logging_1_1logger__holder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1logging_1_1logger__holder__by__value.html">logger_holder_by_value</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows using a log without knowing its full type yet. Even if the log is not fully <b>defined</b>, you can still use it.  <a href="structboost_1_1logging_1_1logger__holder__by__value.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1logging_1_1logger__holder__by__ptr.html">logger_holder_by_ptr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows using a log without knowing its full type yet. Even if the log is not fully <b>defined</b>, you can still use it.  <a href="structboost_1_1logging_1_1logger__holder__by__ptr.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1logging_1_1ensure__early__log__creation.html">ensure_early_log_creation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ensures the log is created before main(), even if not used before main.  <a href="structboost_1_1logging_1_1ensure__early__log__creation.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1logging_1_1forward__to__logger.html">forward_to_logger</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forwards everything to a different <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a>.  <a href="structboost_1_1logging_1_1forward__to__logger.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1logging_1_1logger.html">logger</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> class. Every log from your application is an instance of this (see <a class="el" href="workflow.html#workflow_processing">workflow</a>).  <a href="structboost_1_1logging_1_1logger.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1logging_1_1logger__to__gather.html">logger_to_gather</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> class, finds its gather_msg , without needing to know the logger's definition (a typedef is enough).  <a href="structboost_1_1logging_1_1logger__to__gather.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1logging_1_1implement__default__logger.html">implement_default_logger</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1logging_1_1logger__base.html">logger_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> base class.  <a href="structboost_1_1logging_1_1logger__base.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1logging_1_1tss__ostringstream.html">tss_ostringstream</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents an ostringstream that takes advantage of TSS (Thread Specific Storage). In other words, each thread has its own copy of an ostringstream, thus when needed, we avoid the cost of re-creating it (it's created only once per thread).  <a href="structboost_1_1logging_1_1tss__ostringstream.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1logging_1_1logger__format__write.html">logger_format_write</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes it easier to use a <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> with format_write class.  <a href="structboost_1_1logging_1_1logger__format__write.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging_1_1destination.html">destination</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destination is a <a class="el" href="namespaceboost_1_1logging_1_1manipulator.html" title="Manipulators = Formatters and/or destinations.">manipulator</a>. It contains a place where the message, after being formatted, is to be written to. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging_1_1filter.html">filter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> implementations. A <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> tells the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> if it's enabled or not. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging_1_1format__and__write.html">format_and_write</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <code>format_and_write</code> classes know how to call the <a class="el" href="namespaceboost_1_1logging_1_1formatter.html" title="Formatter is a manipulator. It allows you to format the message before writing it...">formatter</a> and <a class="el" href="namespaceboost_1_1logging_1_1destination.html" title="Destination is a manipulator. It contains a place where the message, after being...">destination</a> <code>objects</code>. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging_1_1formatter.html">formatter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Formatter is a <a class="el" href="namespaceboost_1_1logging_1_1manipulator.html" title="Manipulators = Formatters and/or destinations.">manipulator</a>. It allows you to format the message before writing it to the destination(s). <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging_1_1gather.html">gather</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Classes that implement gathering the message. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging_1_1level.html">level</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handling levels - classes that can hold and/or deal with levels - filters and <a class="el" href="namespaceboost_1_1logging_1_1level.html" title="Handling levels - classes that can hold and/or deal with levels - filters and level...">level</a> holders. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging_1_1lock__resource__finder.html">lock_resource_finder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Possible ways to lock resource for read/write. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging_1_1locker.html">locker</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains implementations of <a class="el" href="namespaceboost_1_1logging_1_1locker.html" title="Contains implementations of locker objects. Such a locker can lock data for read...">locker</a> objects. Such a <a class="el" href="namespaceboost_1_1logging_1_1locker.html" title="Contains implementations of locker objects. Such a locker can lock data for read...">locker</a> can lock data for read or write. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging_1_1manipulator.html">manipulator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manipulators = Formatters and/or destinations. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging_1_1msg__route.html">msg_route</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies the route : how formatting and writing to destinations take place. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging_1_1op__equal.html">op_equal</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements operator== for manipulators. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging_1_1optimize.html">optimize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gathering the message: contains optimizers for formatting and/or destinations: for example, caching techniques. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging_1_1profile.html">profile</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows profiling your application. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging_1_1scenario.html">scenario</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this when you have a specific <a class="el" href="namespaceboost_1_1logging_1_1scenario.html" title="Use this when you have a specific scenario, and want the best logger/filter classes...">scenario</a>, and want the best logger/filter classes that fit that <a class="el" href="namespaceboost_1_1logging_1_1scenario.html" title="Use this when you have a specific scenario, and want the best logger/filter classes...">scenario</a>. Check out <a class="el" href="namespaceboost_1_1logging_1_1scenario_1_1usage.html" title="If you want the library to choose the best logger/filter classes based on how your...">scenario::usage</a> and <a class="el" href="namespaceboost_1_1logging_1_1scenario_1_1ts.html" title="Find out the right logger/filter, based on thread-safety of logger(s)/filter(s).">scenario::ts</a>. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging_1_1tag.html">tag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows you to use tags (extra information about the context of the logged message: file/line, <a class="el" href="structboost_1_1logging_1_1tag_1_1function.html" title="tag that holds function name context information">function</a> name, thread id, etc.), and log this information as well. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging_1_1writer.html">writer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Classes that write the message, once it's been <a class="el" href="namespaceboost_1_1logging_1_1gather.html">gathered</a>. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
<a class="el" href="structboost_1_1logging_1_1ensure__early__log__creation.html">ensure_early_log_creation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging.html#d416a8cfa971668a1db9955b62b4adcb">ensure_early_filter_creation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ensures the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> is created before main(), even if not used before main.  <a href="#d416a8cfa971668a1db9955b62b4adcb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class logger&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structboost_1_1logging_1_1logger.html">logger</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1logging.html#365b730055b5c13d33e4ad97cd0e4f83">get_logger_base</a> (<a class="el" href="structboost_1_1logging_1_1logger.html">logger</a> *l)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Root namespace. All the <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a> lib is contained in this namespace, or sub-namespaces of this one. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="d416a8cfa971668a1db9955b62b4adcb"></a><!-- doxytag: member="boost::logging::ensure_early_filter_creation" ref="d416a8cfa971668a1db9955b62b4adcb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1logging_1_1ensure__early__log__creation.html">ensure_early_log_creation</a> <a class="el" href="structboost_1_1logging_1_1ensure__early__log__creation.html">boost::logging::ensure_early_filter_creation</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ensures the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> is created before main(), even if not used before main. 
<p>
We need this, so that we won't run into multi-threaded issues while the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> is created (in other words, if the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> is created before main(), we can safely assume there's only one thread running, thus no multi-threaded issues) 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="365b730055b5c13d33e4ad97cd0e4f83"></a><!-- doxytag: member="boost::logging::get_logger_base" ref="365b730055b5c13d33e4ad97cd0e4f83" args="(logger *l)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class logger&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structboost_1_1logging_1_1logger.html">logger</a>* boost::logging::get_logger_base           </td>
          <td>(</td>
          <td class="paramtype">logger *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Useful for <a class="el" href="structboost_1_1logging_1_1logger__holder.html" title="Allows using a log without knowing its full type yet. Even if the log is not fully...">logger_holder</a> - to get the logger' base (so that we can use it even without knowing the full log's definition).<p>
If used on a <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a>, it just returns it . 
</div>
</div><p>
<hr>
<br>
<small> Copyright <a href="http://www.torjo.com">John Torjo</a> &copy; 2007
</small> <br>

<small> Have a question/ suggestion/ comment? Send me <a href="http://www.torjo.com/contact.html">feedback</a>
</small> 

</body>
</html>
