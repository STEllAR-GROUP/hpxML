<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Boost Logging Library v2: Declaring/Defining your logger/filter class(es)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
  </ul>
</div>
<h1><a class="anchor" name="defining_your_logger_filter">Declaring/Defining your logger/filter class(es)</a></h1><ul>
<li><a class="el" href="defining_your_logger_filter.html#defining_prerequisites">Prerequisites</a><ul>
<li><a class="el" href="defining_your_logger_filter.html#defining_prerequisites_typedef">Prerequisites - Typedefing</a></li><li><a class="el" href="defining_your_logger_filter.html#defining_prerequisites_dd">Prerequisites - Declare and define</a></li></ul>
</li></ul>
<p>
<ul>
<li><a class="el" href="defining_your_logger_filter.html#typedefing_your_filter">Typedefing your filter class</a><ul>
<li><a class="el" href="defining_your_logger_filter.html#typedefing_your_filter_scenario">Typedefing your filter using scenarios (the easy way)</a></li><li><a class="el" href="defining_your_logger_filter.html#typedefing_your_filter_manually">Typedefing your filter manually</a></li></ul>
</li><li><a class="el" href="defining_your_logger_filter.html#typedefing_your_logger">Typedefing your logger class(es)</a><ul>
<li><a class="el" href="defining_your_logger_filter.html#typedefing_your_logger_scenario">Typedefing your logger using scenarios (the very easy way)</a></li><li><a class="el" href="defining_your_logger_filter.html#typedefing_your_logger_format_write">Typedefing your logger using logger_format_write (the easy way)</a></li><li><a class="el" href="defining_your_logger_filter.html#typedefing_your_logger_use_logger">Typedefing your logger using the logger class</a></li></ul>
</li></ul>
<p>
<ul>
<li><a class="el" href="defining_your_logger_filter.html#declare_define">Declaring and defining your logger and filter</a><ul>
<li><a class="el" href="defining_your_logger_filter.html#declare_define_use_macros">Declaring and defining your logger/filter using macros</a><ul>
<li><a class="el" href="defining_your_logger_filter.html#declare_define_use_macros_under_the_hood">Declaring and defining your logger/filter using macros - what happens under the hood?</a></li><li><a class="el" href="defining_your_logger_filter.html#declare_define_use_macros_as_functions">logger/filter as functions</a></li><li><a class="el" href="defining_your_logger_filter.html#declare_define_use_macros_fast_compile">Fast compiling : On/Off</a></li><li><a class="el" href="defining_your_logger_filter.html#declare_define_use_macros_before_main">Ensuring instantiation before main()</a></li><li><a class="el" href="defining_your_logger_filter.html#declare_define_use_macros_no_after_destroyed">Ensuring you don't use a logger and/or filter after it's been destroyed</a></li></ul>
</li><li><a class="el" href="defining_your_logger_filter.html#declare_define_manually">Declaring and defining your logger/filter manually</a><ul>
<li><a class="el" href="defining_your_logger_filter.html#declare_define_manually_f_vs_v">Functions versus variables</a></li><li><a class="el" href="defining_your_logger_filter.html#declare_define_manually_logger_holder">Using logger_holder class</a></li><li><a class="el" href="defining_your_logger_filter.html#declare_define_manually_before_main">Ensure initialized before main()</a></li></ul>
</li></ul>
</li></ul>
<h2><a class="anchor" name="defining_prerequisites">
Prerequisites</a></h2>
When using the Boost Logging Lib, you need 2 things (see <a class="el" href="workflow.html">Workflow</a>):<ul>
<li>a <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> : which tells you if a <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> is enabled or not. Note that you can use the same <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> for multiple loggers - if you want.</li><li>a <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> : which does the actual <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a>, once it's enabled</li></ul>
<p>
In order to declare/define filters and loggers:<ul>
<li>you have to choose the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> and <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> based on your needs (<a class="el" href="defining_your_logger_filter.html#defining_prerequisites_typedef">typedefing</a>)</li><li>you have to declare and define your fiter and <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> (<a class="el" href="defining_your_logger_filter.html#defining_prerequisites_dd">declare and define</a>)</li></ul>
<p>
<br>
<br>
 <h3><a class="anchor" name="defining_prerequisites_typedef">
Prerequisites - Typedefing</a></h3>
Typedefing your filter/logger is the process where you find the <code>type</code> of your filter/logger.<p>
Example 1: <div class="fragment"><pre class="fragment"><span class="keyword">using namespace </span>boost::logging::scenario::usage;
<span class="keyword">typedef</span> use&lt; filter_::change::often&lt;10&gt; &gt; finder;
<span class="comment">// now, finder::logger contains the logger type and finder::filter contains the filter type</span>
</pre></div><p>
Example 2: <div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>bl = boost::logging;
<span class="keyword">typedef</span> <a class="code" href="structboost_1_1logging_1_1logger__format__write.html" title="Makes it easier to use a logger with format_write class.">bl::logger_format_write&lt; &gt;</a> logger_type;
<span class="keyword">typedef</span> <a class="code" href="structboost_1_1logging_1_1filter_1_1no__ts.html" title="Manages is_enabled/set_enabled in a non-thread-safe way.">bl::filter::no_ts</a> filter_type;
</pre></div><p>
<br>
<br>
 <h3><a class="anchor" name="defining_prerequisites_dd">
Prerequisites - Declare and define</a></h3>
Now that you know the types of your logger(s) and filter(s), you have to declare and define them. The easiest way is to use the <code>BOOST_DECLARE_LOG*</code> and <code>BOOST_DEFINE_LOG*</code> macros:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// in a header file</span>
BOOST_DECLARE_LOG_FILTER(g_log_filter, filter_type ) 
BOOST_DECLARE_LOG(g_l, logger_type) 

<span class="comment">// in a source file</span>
BOOST_DEFINE_LOG_FILTER(g_log_filter, filter_type ) 
BOOST_DEFINE_LOG(g_l, logger_type) 

<span class="comment">// ... manipulating the logger/filter in the code</span>
g_l()-&gt;writer().add_formatter( formatter::idx(), "[%] "  );
g_log_filter()-&gt;set_enabled(false);
</pre></div><p>
However, there are other ways to declare/define your loggers/filters. We'll explore them <a class="el" href="defining_your_logger_filter.html#declare_define">later</a>.<p>
<br>
<br>
 <h2><a class="anchor" name="typedefing_your_filter">
Typedefing your filter class</a></h2>
<h3><a class="anchor" name="typedefing_your_filter_scenario">
Typedefing your filter using scenarios (the easy way)</a></h3>
You can declare/define both your <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> and <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> based on how you'll use them (<a class="el" href="namespaceboost_1_1logging_1_1scenario_1_1usage.html" title="If you want the library to choose the best logger/filter classes based on how your...">scenario::usage</a>). Thus, you'll deal with the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> like this:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="format__fwd_8hpp.html">boost/logging/format_fwd.hpp</a>&gt;</span>
<span class="keyword">using namespace </span>boost::logging::scenario::usage;
<span class="keyword">typedef</span> use&lt;
        <span class="comment">// how often does the filter change?</span>
        filter_::change::often&lt;10&gt;, 
        <span class="comment">// does the filter use levels?</span>
        filter_::level::no_levels, 
        <span class="comment">// logger info</span>
        ...
        &gt; finder;

<span class="comment">// declare filter</span>
BOOST_DECLARE_LOG_FILTER(g_log_filter, finder::filter ) 

<span class="comment">// define filter</span>
BOOST_DEFINE_LOG_FILTER(g_log_filter, finder::filter ) 
</pre></div><h3><a class="anchor" name="typedefing_your_filter_manually">
Typedefing your filter manually</a></h3>
This is where you manually specify the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> class you want. There are multiple <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> implementations:<ul>
<li>not using levels - the classes from the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> namespace</li><li>using levels - the classes from the <a class="el" href="namespaceboost_1_1logging_1_1level.html" title="Handling levels - classes that can hold and/or deal with levels - filters and level...">level</a> namespace</li></ul>
<p>
Choose any you wish:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="format__fwd_8hpp.html">boost/logging/format_fwd.hpp</a>&gt;</span>

<span class="comment">// declare filter</span>
BOOST_DECLARE_LOG_FILTER(g_log_filter, filter::no_ts ) 

BOOST_DEFINE_LOG_FILTER(g_log_filter, filter::no_ts ) 
</pre></div><h2><a class="anchor" name="typedefing_your_logger">
Typedefing your logger class(es)</a></h2>
<h3><a class="anchor" name="typedefing_your_logger_scenario">
Typedefing your logger using scenarios (the very easy way)</a></h3>
When you use formatters and destinations, you can declare/define both your <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> and <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> based on how you'll use them (<a class="el" href="namespaceboost_1_1logging_1_1scenario_1_1usage.html" title="If you want the library to choose the best logger/filter classes based on how your...">scenario::usage</a>). Thus, you'll deal with the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> like this:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="format__fwd_8hpp.html">boost/logging/format_fwd.hpp</a>&gt;</span>

<span class="keyword">using namespace </span>boost::logging::scenario::usage;
<span class="keyword">typedef</span> use&lt;
        <span class="comment">// filter info</span>
        ...,
        <span class="comment">// how often does the logger change?</span>
        logger_::change::often&lt;10&gt;, 
        <span class="comment">// what does the logger favor?</span>
        logger_::favor::speed&gt; finder;

<span class="comment">// declare</span>
BOOST_DECLARE_LOG(g_log_err, finder::logger ) 

<span class="comment">// define</span>
BOOST_DEFINE_LOG(g_log_err, finder::logger ) 
</pre></div><h3><a class="anchor" name="typedefing_your_logger_format_write">
Typedefing your logger using logger_format_write (the easy way)</a></h3>
When you use formatters and destinations, you can use the <a class="el" href="structboost_1_1logging_1_1logger__format__write.html" title="Makes it easier to use a logger with format_write class.">logger_format_write</a> class. The template params you don't want to set, just leave them <code>default_</code>.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="format__fwd_8hpp.html">boost/logging/format_fwd.hpp</a>&gt;</span>

<span class="keyword">namespace </span>bl = boost::logging;
<span class="keyword">typedef</span> <a class="code" href="structboost_1_1logging_1_1logger__format__write.html" title="Makes it easier to use a logger with format_write class.">bl::logger_format_write&lt; bl::default_, bl::default_, bl::writer::threading::on_dedicated_thread &gt;</a> logger_type;

<span class="comment">// declare</span>
BOOST_DECLARE_LOG(g_l, logger_type) 

<span class="comment">// define</span>
BOOST_DEFINE_LOG(g_l, logger_type)
</pre></div><h3><a class="anchor" name="typedefing_your_logger_use_logger">
Typedefing your logger using the logger class</a></h3>
In case you don't use formatters and destinations, or have custom needs that the above methods can't satisfy, or just like to do things very manually, you can use the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> class directly:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="logging_8hpp.html">boost/logging/logging.hpp</a>&gt;</span>

<span class="keyword">typedef</span> logger&lt; gather::ostream_like::return_str&lt;&gt;, <a class="code" href="namespaceboost_1_1logging_1_1destination.html#cbd9de4234f411c7b7779cf724f51ed0" title="cout_t with default values. See cout_t">destination::cout</a>&gt; logger_type;

<span class="comment">// declare</span>
BOOST_DECLARE_LOG(g_l, logger_type) 

<span class="comment">// define</span>
BOOST_DEFINE_LOG(g_l, logger_type)
</pre></div><p>
<br>
<br>
 <h2><a class="anchor" name="declare_define">
Declaring and defining your logger and filter</a></h2>
At this point, you <em>have</em> your <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> class and your <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> class. Lets assume they are <code>logger_type</code> and <code>filter_type</code>. You could have obtained them like this:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>bl = boost::logging;
<span class="keyword">typedef</span> <a class="code" href="structboost_1_1logging_1_1logger__format__write.html" title="Makes it easier to use a logger with format_write class.">bl::logger_format_write&lt; &gt;</a> logger_type;
<span class="keyword">typedef</span> <a class="code" href="structboost_1_1logging_1_1filter_1_1no__ts.html" title="Manages is_enabled/set_enabled in a non-thread-safe way.">bl::filter::no_ts</a> filter_type;
</pre></div><p>
<br>
<br>
 <h3><a class="anchor" name="declare_define_use_macros">
Declaring and defining your logger/filter using macros</a></h3>
This is the simplest way to declare/define your filters.<p>
Declaring:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// in a header file</span>

<span class="preprocessor">#include &lt;<a class="code" href="format__fwd_8hpp.html">boost/logging/format_fwd.hpp</a>&gt;</span>
<span class="comment">// if you don't use formatters/destinations, you can include only &lt;boost/logging/logging.hpp&gt;</span>

<span class="comment">// declare a filter, called g_log_filter</span>
BOOST_DECLARE_LOG_FILTER(g_log_filter, filter_type) 

<span class="comment">// declare a logger, called g_log</span>
BOOST_DECLARE_LOG(g_log, logger_type)
</pre></div><p>
Defining:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// in a source file</span>
<span class="preprocessor">#include &lt;<a class="code" href="format_8hpp.html">boost/logging/format.hpp</a>&gt;</span>

<span class="comment">// define a filter, called g_log_filter</span>
BOOST_DEFINE_LOG_FILTER(g_log_filter, filter_type) 

<span class="comment">// define a logger, called g_log</span>
BOOST_DEFINE_LOG(g_log, logger_type)
</pre></div><p>
Specifying some arguments when defining the logger/filter: <div class="fragment"><pre class="fragment"><span class="comment">// in a source file</span>
<span class="preprocessor">#include &lt;<a class="code" href="format_8hpp.html">boost/logging/format.hpp</a>&gt;</span>

<span class="comment">// define a filter, called g_log_filter - assuming it needs an 2 arguments at construction</span>
BOOST_DEFINE_LOG_FILTER_WITH_ARGS(g_log_filter, filter_type, (level::debug, <span class="keyword">true</span>) ) 

<span class="comment">// define a logger, called g_log - assuming it needs an extra argument at construction</span>
BOOST_DEFINE_LOG_WITH_ARGS(g_log, logger_type, ("log.txt") )
</pre></div><p>
<br>
<br>
 <h3><a class="anchor" name="declare_define_use_macros_under_the_hood">
Declaring and defining your logger/filter using macros - what happens under the hood?</a></h3>
When using the <code>BOOST_DECLARE_LOG*</code> and <code>BOOST_DEFINE_LOG*</code> macros, this is what the lib takes care for you:<ol type=1>
<li>it declares and defines a logger/filter name, as a <b>function</b> (which internally contains a static variable)</li><li>cares about Fast Compile (default) or not</li><li>ensures the logger/filter object is instantiated before <code>main()</code>, even if not used before main(). This is very useful, since we can assume that before main() there won't be more than 1 threads, thus no problems at initializing the static variable.</li><li>ensures we don't <a class="el" href="after_destruction.html">use a logger and/or filter after it's been destroyed</a></li></ol>
<p>
<br>
<br>
 <h4><a class="anchor" name="declare_define_use_macros_as_functions">
logger/filter as functions</a></h4>
We declare/define the logger/filter as a function, in order to avoid being used before it's initialized. Example:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Translation unit 1:</span>
logger&lt;...&gt; g_l;

<span class="comment">// Translation unit 2:</span>
<span class="keyword">struct </span>widget {
    widget() {
        <span class="comment">// use g_l</span>
        g_l.writer() ....
    }
} g_global_widget;
</pre></div><p>
In the above code we have 2 global variables (g_l and g_global_widget) in 2 different translation units. In this case, it's unspecified which will be constructed first - thus, we could end up having g_global_widget constructed first, and using g_l before g_l is initialized.<p>
To avoid this, g_l should be a function, like this:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Translation unit 1:</span>
logger&lt;...&gt; &amp; g_l() { <span class="keyword">static</span> logger&lt;...&gt; l; <span class="keywordflow">return</span> l; }

<span class="comment">// Translation unit 2:</span>
<span class="keyword">struct </span>widget {
    widget() {
        <span class="comment">// use g_l</span>
        g_l().writer() ....
    }
} g_global_widget;
</pre></div><p>
In the above case, when g_l() is used for the first time, it constructs the local <code>l</code>, and it all works. The <code>BOOST_DECLARE_LOG*</code> and <code>BOOST_DEFINE_LOG*</code> macros take care of this automatically.<p>
<br>
<br>
 <h4><a class="anchor" name="declare_define_use_macros_fast_compile">
Fast compiling : On/Off</a></h4>
The <code>BOOST_DECLARE_LOG*</code> and <code>BOOST_DEFINE_LOG*</code> macros also automatically take care of fast compiling or not.<p>
Fast compiling (on by default) applies only to loggers. It means that you can use the loggers in code, even without knowing their definition. More to the point, you can log messages throughout your application, even if you don't know the full type of the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> (a <em>typedef</em> is enough). This avoids inclusion of a lot of header files, speeding the compile process.<p>
If fast compile is on, you only need this when using logs:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// usually in a header file</span>
<span class="preprocessor">#include &lt;<a class="code" href="format__fwd_8hpp.html">boost/logging/format_fwd.hpp</a>&gt;</span>
<span class="keyword">typedef</span> logger_format_write&lt; &gt; logger_type;

BOOST_DECLARE_LOG(g_l, logger_type) 

<span class="comment">// macro used for logging</span>
<span class="preprocessor">#define L_ BOOST_LOG_USE_LOG_IF_FILTER(g_l(), g_log_filter()-&gt;is_enabled() ) </span>
<span class="preprocessor"></span>

<span class="comment">// in your code, only by #including boost/logging/format_fwd.hpp, you can log messages</span>
L_ &lt;&lt; <span class="stringliteral">"this is so cool "</span> &lt;&lt; i++;
std::string hello = <span class="stringliteral">"hello"</span>, world = <span class="stringliteral">"world"</span>;
L_ &lt;&lt; hello &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; world;
</pre></div><p>
If fast compile is off, when using the logs, you'll need to know the full type of the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> (the definition of the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> class). <br>
 When using formatters/destinations, this means <code>#include &lt;<a class="el" href="format_8hpp.html">boost/logging/format.hpp</a>&gt;</code>. Also, when <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a> a message, the code for doing the actual <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a> will be generated inline, this taking a bit of compilation time.<p>
<a class="el" href="macros.html#macros_compile_time">More details here</a>.<p>
In short,<p>
When fast compile is off, BOOST_DEFINE_LOG will generate code similar to this:<p>
<div class="fragment"><pre class="fragment">logger_type * g_l() { <span class="keyword">static</span> logger_type l; <span class="keywordflow">return</span> &amp;l; }
</pre></div><p>
When fast compile is on, BOOST_DEFINE_LOG will generate code similar to this:<p>
<div class="fragment"><pre class="fragment">logger_holder&lt;logger_type&gt; &amp; g_l() { <span class="keyword">static</span> logger_holder_by_value&lt;logger_type&gt; l; <span class="keywordflow">return</span> l; }
</pre></div><p>
In the latter case, logger_holder&lt;&gt; holds a pointer to the original log, and when a message is logged, it forwards it to the real <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> (implemented in <a class="el" href="structboost_1_1logging_1_1logger__holder__by__value.html" title="Allows using a log without knowing its full type yet. Even if the log is not fully...">logger_holder_by_value</a>).<p>
<br>
<br>
 <h4><a class="anchor" name="declare_define_use_macros_before_main">
Ensuring instantiation before main()</a></h4>
The <code>BOOST_DECLARE_LOG*</code> and <code>BOOST_DEFINE_LOG*</code> macros also automatically ensure that the logger/filter is instantiated before main(). This is very useful, since we can assume that before main() there won't be more than 1 threads, thus no problems at initializing the static variable.<p>
For this, it uses the <code><a class="el" href="structboost_1_1logging_1_1ensure__early__log__creation.html" title="Ensures the log is created before main(), even if not used before main.">ensure_early_log_creation</a></code> class, like this:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// this will ensure g_l() is called before main(), even if not used anywhere else before main()</span>
ensure_early_log_creation ensure( g_l() );
</pre></div><p>
<br>
<br>
 <h4><a class="anchor" name="declare_define_use_macros_no_after_destroyed">
Ensuring you don't use a logger and/or filter after it's been destroyed</a></h4>
See <a class="el" href="after_destruction.html">this</a> for more details.<p>
<br>
<br>
 <h3><a class="anchor" name="declare_define_manually">
Declaring and defining your logger/filter manually</a></h3>
As explained <a class="el" href="defining_your_logger_filter.html#declare_define_use_macros">above</a>, you can use macros to declare/define your loggers/filters.<p>
Of course, you can declare/define them manually. If you decide to do it, please read the <a class="el" href="defining_your_logger_filter.html#declare_define_use_macros">Define/declare ... macros</a> section throughly, so that you know what you should watch for.<p>
For example, declaring/defining your <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> can be as easy as:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// in a header file</span>
logger_type * g_l();

<span class="comment">// example of macro used for logging</span>
<span class="preprocessor">#define L_ BOOST_LOG_USE_LOG_IF_FILTER(g_l(), g_log_filter()-&gt;is_enabled() ) </span>
<span class="preprocessor"></span>

<span class="comment">// in a source file</span>
logger_type * g_l() { <span class="keyword">static</span> logger_type l; <span class="keywordflow">return</span> &amp;l; } 

<span class="comment">// example of usage</span>
L_ &lt;&lt; <span class="stringliteral">"this is so cool "</span> &lt;&lt; i++;
std::string hello = <span class="stringliteral">"hello"</span>, world = <span class="stringliteral">"world"</span>;
L_ &lt;&lt; hello &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; world;
</pre></div><p>
<br>
<br>
 <h4><a class="anchor" name="declare_define_manually_f_vs_v">
Functions versus variables</a></h4>
As I said, you should prefer <a class="el" href="defining_your_logger_filter.html#declare_define_use_macros_as_functions">functions instead of variables</a> for the obvious reasons.<p>
Thus (when using functions), your code should look like:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// in a header file</span>
logger_type * g_l();

<span class="comment">// example of macro used for logging</span>
<span class="preprocessor">#define L_ BOOST_LOG_USE_LOG_IF_FILTER(g_l(), g_log_filter()-&gt;is_enabled() ) </span>
<span class="preprocessor"></span>

<span class="comment">// in a source file</span>
logger_type * g_l() { <span class="keyword">static</span> logger_type l; <span class="keywordflow">return</span> &amp;l; } 

<span class="comment">// example of usage</span>
L_ &lt;&lt; <span class="stringliteral">"this is so cool "</span> &lt;&lt; i++;
std::string hello = <span class="stringliteral">"hello"</span>, world = <span class="stringliteral">"world"</span>;
L_ &lt;&lt; hello &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; world;
</pre></div><p>
<br>
 You can use variables, provided that <a class="el" href="defining_your_logger_filter.html#declare_define_use_macros_as_functions">you know the risks</a>.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// in a header file</span>
<span class="keyword">extern</span> logger_type g_l;

<span class="comment">// example of macro used for logging</span>
<span class="preprocessor">#define L_ BOOST_LOG_USE_LOG_IF_FILTER((*g_l), g_log_filter()-&gt;is_enabled() ) </span>
<span class="preprocessor"></span>

<span class="comment">// in a source file</span>
logger_type g_l;

<span class="comment">// example of usage</span>
L_ &lt;&lt; <span class="stringliteral">"this is so cool "</span> &lt;&lt; i++;
std::string hello = <span class="stringliteral">"hello"</span>, world = <span class="stringliteral">"world"</span>;
L_ &lt;&lt; hello &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; world;
</pre></div><p>
<br>
<br>
 <h4><a class="anchor" name="declare_define_manually_logger_holder">
Using logger_holder class</a></h4>
You should use <code>logger_holder&lt;&gt;</code> when you want to be able to use the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> without knowing its definition (in other words, you only have a typedef). Thus, you'll only need to include &lt;<a class="el" href="format__fwd_8hpp.html">boost/logging/format_fwd.hpp</a>&gt; throughout the application.<p>
In case you're using formatters and destinations, you'll need to include &lt;<a class="el" href="format_8hpp.html">boost/logging/format.hpp</a>&gt; :<ul>
<li>when defining the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a></li><li>when initializing it</li></ul>
<p>
Note that this will involve a virtual function call for each logged message - when performing the actual <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a>.<p>
<code>logger_holder&lt;logger&gt;</code> is the base class - the one that will be used in code/presented to clients. The possible implementations are :<ul>
<li>logger_holder_by_value&lt;logger&gt; - holds the original <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> by value<ul>
<li>in case you think the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> could be used after it's been destroyed, you should use this</li></ul>
</li><li>logger_holder_by_ptr&lt;logger&gt; - holds the original <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> as a pointer (allocates it constructor, deallocates it in destructor)</li></ul>
<p>
Example of using logger_holder&lt;&gt; :<p>
<div class="fragment"><pre class="fragment"><span class="comment">// in a header file</span>
logger_holder&lt;logger_type&gt; &amp; g_l();

<span class="comment">// example of macro used for logging</span>
<span class="preprocessor">#define L_ BOOST_LOG_USE_LOG_IF_FILTER(g_l(), g_log_filter()-&gt;is_enabled() ) </span>
<span class="preprocessor"></span>

<span class="comment">// in a source file</span>
logger_holder&lt;logger_type&gt; &amp; g_l() {
  <span class="keyword">static</span> logger_holder_by_value&lt;logger_type&gt; l;
  <span class="keywordflow">return</span> l;
}

<span class="comment">// example of usage</span>
L_ &lt;&lt; <span class="stringliteral">"this is so cool "</span> &lt;&lt; i++;
std::string hello = <span class="stringliteral">"hello"</span>, world = <span class="stringliteral">"world"</span>;
L_ &lt;&lt; hello &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; world;
</pre></div><p>
<br>
<br>
 <h4><a class="anchor" name="declare_define_manually_before_main">
Ensure initialized before main()</a></h4>
If you use loggers/filters as global variables, you don't need to worry about this.<p>
If you use loggers/filters as functions with static variables, they will be initialized on first usage.<p>
This could be problematic, in case the variable is initialized when more than one thread is running. In some current implementations , if 2 threads are calling the function at the same time (and when each function enters, needs to construct the variable), you might end up with 2 different instances of the same static variable. Thus, trouble.<p>
The easy solution is to use <code><a class="el" href="structboost_1_1logging_1_1ensure__early__log__creation.html" title="Ensures the log is created before main(), even if not used before main.">ensure_early_log_creation</a></code> class, like this:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// in the source file</span>
logger_holder&lt;logger_type&gt; &amp; g_l() {
  <span class="keyword">static</span> logger_holder_by_value&lt;logger_type&gt; l;
  <span class="keywordflow">return</span> l;
}
ensure_early_log_creation ensure( g_l() );
</pre></div><p>
This will ensure the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> is initialized before main(), thus the above problem does not happen. <hr>
<br>
<small> Copyright <a href="http://www.torjo.com">John Torjo</a> &copy; 2007
</small> <br>

<small> Have a question/ suggestion/ comment? Send me <a href="http://www.torjo.com/contact.html">feedback</a>
</small> 

</body>
</html>
