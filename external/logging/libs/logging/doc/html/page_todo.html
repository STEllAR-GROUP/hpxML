<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Boost Logging Library v2: TODOs</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
  </ul>
</div>
<h1><a class="anchor" name="page_todo">TODOs</a></h1>Types of priorities:<ul>
<li>must_have - this is a must have</li><li>high - high priority</li><li>normal - normal priority</li><li>low - nice to have</li></ul>
<p>
<ul>
<li><a class="el" href="page_todo.html#todo_implementation">Implementation</a></li><li><a class="el" href="page_todo.html#todo_docs">Documentation</a></li><li><a class="el" href="page_todo.html#todo_formatters">Formatters</a></li><li><a class="el" href="page_todo.html#todo_destinations">Destinations</a></li></ul>
<p>
Lots of things on my plate ;) <br>
 If you want to make sure a feature is implemented sooner, drop me a note: <a href="http://torjo.com/contact.html">http://torjo.com/contact.html</a><h2><a class="anchor" name="todo_implementation">
Implementation</a></h2>
<ul>
<li><code>normal</code> destination::stream_ptr - just like stream, but hold the stream as a shared pointer. Thus , we won't have to worry about outliving the stream.</li></ul>
<p>
<ul>
<li><code>normal</code> make it possible to initialize from a file - thus we'd need no caching! also allow for extra syntax for the named_writer - {} - to be applied to a <a class="el" href="namespaceboost_1_1logging_1_1destination.html" title="Destination is a manipulator. It contains a place where the message, after being...">destination</a> this way, you can specify some extra formatters to be applied only to a specific <a class="el" href="namespaceboost_1_1logging_1_1destination.html" title="Destination is a manipulator. It contains a place where the message, after being...">destination</a></li></ul>
<p>
<ul>
<li><code>normal</code> on_dedicated_thead - remove dependency on boost::thread</li></ul>
<p>
<ul>
<li><code>normal</code> on_dedicated_thead - I should see it I use logger::always_accurate increases <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a> time as opposed to some caching strategy. I'm asking this because even if we were to use a critical section on the base_type writer's operator(), this will always* happen on the dedicated thread. Thus, I would think it should have very small overhead</li></ul>
<p>
<ul>
<li><code>normal</code> must have helper to call on on_destructed - like, to be able to write to cout,etc</li></ul>
<p>
<ul>
<li><code>normal</code> turn_cache_off() -&gt; find better name, like mark_init_complete() (add a function named like this to call turn_cache_off()).</li></ul>
<p>
<ul>
<li><code>normal</code> have a logger_with_filter class, to make using the lib easier (this would hold the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> and the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a>).</li></ul>
<p>
<ul>
<li><code>high</code> <a class="el" href="namespaceboost_1_1logging_1_1destination.html#1bdbe209347a0ab6c4f0f472ac0ddbe0" title="stream_t with default values. See stream_t">destination::stream</a> - have flush() and flush_each_time</li></ul>
<p>
<ul>
<li><code>high</code> writer::named_write&lt;&gt; need to allow tags by default, here!</li></ul>
<p>
<ul>
<li><code>high</code> scenario::use class - have gather and write typedefs !!! this way we can have: <a class="el" href="structboost_1_1logging_1_1named__logger.html" title="named_logger&lt;...&gt;type finds a logger that uses writer::named_write&lt;&gt;...">named_logger</a>&lt; finder::gather , writer::named&lt;finder::writer&gt; &gt; same goes for <a class="el" href="structboost_1_1logging_1_1logger__format__write.html" title="Makes it easier to use a logger with format_write class.">logger_format_write</a> class.</li></ul>
<p>
<ul>
<li><code>normal</code> make it so that I use BOOST_LOG_USE_WCHAR_T as little as possible for instance, it's not needed in cout_t, cerr_t.</li></ul>
<p>
<ul>
<li><code>high</code> cut down compile time: make it compile faster (most likely improve use_format_write, etc)</li></ul>
<p>
<ul>
<li><code>high</code> named_write&lt;&gt; - due to <a class="el" href="known_issues.html#known_issue_modifying_manipulator">Modifying a manipulator while it's used</a> - whenever I modify the format and/or <a class="el" href="namespaceboost_1_1logging_1_1destination.html" title="Destination is a manipulator. It contains a place where the message, after being...">destination</a> string, i need to add/delete all formatters and/or destinations in order to avoid that <a class="el" href="namespaceboost_1_1logging_1_1scenario.html" title="Use this when you have a specific scenario, and want the best logger/filter classes...">scenario</a> TOTHINK</li></ul>
<p>
<ul>
<li><code>high</code> logger_format_write&lt;&gt; should be just like other find classes - have logger_format_write&lt;&gt;::type this should uncomplicate code a bit - at least specializing logger_to_gather/writer for logger_format_write&lt;&gt;. <br>
 I will first need to see if this will cut down compilation time or not.</li></ul>
<p>
<ul>
<li><code>normal</code> profiler - we can care about threads as well (that is, for instance, when <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a> on another thread, see how much time it takes from the threads that actually work)</li></ul>
<p>
<ul>
<li><code>low</code> in the same way I've created convert_to_base(), I can create a convert_to_top(), on top of which I can create my own way to <a class="el" href="namespaceboost_1_1logging_1_1gather.html" title="Classes that implement gathering the message.">gather</a> message, and then write it.</li></ul>
<p>
<ul>
<li><code>low</code> when leaking/not leaking loggers/using after_destroyed - have a templated class that allows this (only if users ask for it) I could probably do a bit more about caching as well - however, in this case, I should allow for macros to be visible in client code (for instance, if client wants BOOST_LOG_BEFORE_INIT_USE_CACHE_FILTER)</li></ul>
<p>
<ul>
<li><code>high</code> test TSS on vs2003 and gcc/pthreads <br>
 (note: tested on pthreads; however - about internal implementation : 2 TSS objects are leaked on pthreads, need to see why)</li></ul>
<p>
<ul>
<li><code>normal</code> allow to see how much time <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a> actually takes <br>
 This should work even if <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a> happens on a dedicated thread. Give a name to your tracker - so you can track <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a> time when messages are logged, and time <a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a> actually happens (on dedicated thread). I should feature this on the documentation - I don't think any other lib has this! I should be able to add this for <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> as well.</li></ul>
<p>
<ul>
<li><code>low</code> configuration : should allow the library to be configured at runtime, from a file, much like log4j note: see <a class="el" href="namespaceboost_1_1logging_1_1formatter.html#11ac49ef32ec7287cf79641151f61b2c" title="named_spacer_t with default values. See named_spacer_t">formatter::named_spacer</a>, <a class="el" href="namespaceboost_1_1logging_1_1destination.html#b351c554414e36c59935332dd8ccc6bb" title="named_t with default values. See named_t">destination::named</a><ul>
<li>Votes : 1</li></ul>
</li></ul>
<p>
<ul>
<li><code>low</code> hierarchical logs : just like log4j - be able to have some logs inherit from parent logs I can implement this in multiple ways - one would be to use function names (BOOST_CURRENT_FUNCTION) and see the namespace/class name from there. Or, I could implement it using __FILE__.<ul>
<li>Votes: 1</li></ul>
</li></ul>
<p>
<ul>
<li><code>low</code> have a "class"/"function" <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> <br>
 - so basically you can have is_enabled(this), which will call is_enabled&lt;some_type&gt;, which you can later on, or at runtime, enable or disable. --&gt; turn on/off based on class name (typeid(name).string() - could be problematic in case the names are cryptic. What i can do is register some classes - with their name, so that you have a one-to-one corresp. you can even enforce a class to register its name TOTHINK <br>
 note: this can be viewed as a hierarchical <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a>. In the same way, I could create a hierarchical <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> (that is, find the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a>, based on __FILE__ or __FUNCTION__) <br>
 Implementation details: <br>
 have a <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> based on file name (the __FILE__) - should use TSS. comparing is very simple and efficient. std::map&lt;const char*,bool, char_cmp&gt;; <br>
 std::map&lt;std::string,bool&gt; enabled; <br>
 -- the idea is that a __FILE__ is a const char* and will always have the same (pointer) value. So once I know if it's enabled or not, it'll always be like that. once specifically turned on/off - we update the 2 maps</li></ul>
<p>
<ul>
<li><code>low</code> composite_filter <br>
 I want to allow an and_filter = filter1 &amp;&amp; filter2, and an or_filter = filter1 || filter2. to see how I can find out if such a <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> is enabled or not - for instance, receive 2 args = pass 1 to filter1 and 2 to filter2; or if get only one arg, you need to specify to whom to pass to</li></ul>
<p>
<ul>
<li><code>low</code> Design: logged assert. I believe log library needs to provide support for custom assert. Such assert would log into log file and invoke system assert depends in assert <a class="el" href="namespaceboost_1_1logging_1_1level.html" title="Handling levels - classes that can hold and/or deal with levels - filters and level...">level</a>. It could be an addon to core functionality. <br>
 Note: SMART_ASSERT should be used for this.</li></ul>
<p>
<ul>
<li><code>normal</code> Allow using log from DLL and EXE (on Windows). Same for Linux. This should normally work - just need to explain how.</li></ul>
<h2><a class="anchor" name="todo_formatters">
Formatters</a></h2>
<ul>
<li><code>low</code> new <a class="el" href="namespaceboost_1_1logging_1_1formatter.html" title="Formatter is a manipulator. It allows you to format the message before writing it...">formatter</a>: limit the text to gives maximal length. It may happend the dump is unexpectedly large and would fill disk/overwrite cache/take too much time/be unreadable. Limiting one log size would help here a lot and would relieve end user of doing it manually.</li></ul>
<p>
<ul>
<li><code>normal</code> quite often I am not interested not in absolute time (2005/12/11 16:33) but in time offset from some event. I suggest to add API: <br>
 some_formatter.set_time_start_point( bool either_in_all_threads_or_just_in_current_thread); <br>
 and escape sequences: <br>
 $Xms - e.g. "12 ms", "78321 ms" (only milliseconds are used) <br>
 $Xsec - e.g. "2 s, 23 ms" (only seconds and millis) <br>
 $Xmin - e.g. "3 m, 21 s, 10 ms" <br>
 $Xhour - e.g. "1 h, 33 m, 20 s, 54 ms" <br>
 $Xday - e.g. "2 d, 1 h, 33 m, 20 s, 54 ms" <br>
</li></ul>
<p>
<ul>
<li><code>normal</code> new <a class="el" href="namespaceboost_1_1logging_1_1formatter.html" title="Formatter is a manipulator. It allows you to format the message before writing it...">formatter</a>: thread ID (both Win32 and POSIX) is of low use. I suggest to add API to specify string name as alternative to thread ID formatter.set_current_thread_name("gui thread");</li></ul>
<p>
<ul>
<li><code>normal</code> Time string cashing time and time_strf calls are not cashed. It's a lot of work for nothing. Note: should use TSS</li></ul>
<p>
<ul>
<li><code>normal</code> Design: hexdump. I believe log library needs to provide support for dumping memory in hex format on log file.</li></ul>
<h2><a class="anchor" name="todo_destinations">
Destinations</a></h2>
<ul>
<li><code>normal</code> new <a class="el" href="namespaceboost_1_1logging_1_1destination.html" title="Destination is a manipulator. It contains a place where the message, after being...">destination</a> : to Event log</li></ul>
<p>
<ul>
<li><code>normal</code> shared_memory is to use interprocess lib.</li></ul>
<h2><a class="anchor" name="todo_docs">
Documentation</a></h2>
<ul>
<li><code>low</code> add "for documentation, see http://www.boost.org/lib/logging/" to each file</li></ul>
<p>
<ul>
<li><code>low</code> have a document with differences from v1 and v2<ul>
<li>Votes: 1</li></ul>
</li></ul>
<p>
<ul>
<li><code>normal</code> explain BOOST_LOG_USE_SIMPLE_LOG_IF_FILTER (defining_logger_macros)</li></ul>
<p>
<ul>
<li><code>normal</code> explain about cachestring clases</li></ul>
<p>
<ul>
<li><code>normal</code> about is_generic formatters/destinations (note that I might have already written about this)</li></ul>
<p>
<ul>
<li><code>low</code> Nice to have docs wish: a page discussing stranghts of this <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> vs other common ones (log4cpp etc).</li></ul>
<p>
<ul>
<li><code>normal</code> Documentation about performance of the library is missing - absolute times, # of dynamic allocations per typical log, etc.</li></ul>
<p>
<ul>
<li><code>high</code> For formatters/destinations - make it easier to see - not necessary from examples. By looking at the namespace itself, it contains other stuff as well. See if I can use @ ingroup or something</li></ul>
<p>
<ul>
<li><code>normal</code> Explain about config files - you can use named_spacer,named.</li></ul>
<p>
<ul>
<li><code>high</code> explain about common_base()</li></ul>
<p>
<ul>
<li><code>high</code> on_dedicated_thread : explain about manipulating it - while pause() TOTHINK if I can automate this</li></ul>
<p>
<ul>
<li><code>normal</code> "Manipulating thy manipulator" - another way is to create another <a class="el" href="namespaceboost_1_1logging_1_1manipulator.html" title="Manipulators = Formatters and/or destinations.">manipulator</a>, delete the current one , and add the new one i should explain that this could not work immediately because of caching.</li></ul>
<p>
<ul>
<li><code>normal</code> scoped logs - scoped_write_msg - explain that you need to implement this in case you have your own gather.read_msg().out() class </li></ul>
<hr>
<br>
<small> Copyright <a href="http://www.torjo.com">John Torjo</a> &copy; 2007
</small> <br>

<small> Have a question/ suggestion/ comment? Send me <a href="http://www.torjo.com/contact.html">feedback</a>
</small> 

</body>
</html>
