<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Boost Logging Library v2: Thread safety</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
  </ul>
</div>
<h1><a class="anchor" name="thread_safety">Thread safety</a></h1>When talking about thread-safety, there are 2 types of things to consider:<ul>
<li>the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> class(es)</li><li>the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> class(es)</li></ul>
<p>
Based on your application, you can fine tune any of the above to suit your needs:<ul>
<li>use it as single threaded</li><li>use <a class="el" href="macros.html#macros_tss">TSS</a> (Thread Specific Storage)<ul>
<li>use TSS - have some data you modify thread-safe(using mutexes), and have each thread cache the value, and refresh at a given period (very efficient)</li><li>initialize your logger/filter only once, and once it's initialized, always use that value (very efficient)</li></ul>
</li><li>thread-safe (use mutexes) - every access uses a mutex; very slow in comparison to the above methods</li></ul>
<p>
In addition to the above, for loggers, you can have an even faster method of writing the messages to their destinations: <a class="el" href="structboost_1_1logging_1_1writer_1_1on__dedicated__thread.html">on a dedicated thread</a>.<p>
<br>
<br>
 The easiest way to specify the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> and <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> classes, is to <a class="el" href="namespaceboost_1_1logging_1_1scenario_1_1usage.html">customize the lib to suit your application's needs</a>.<p>
Alternatively, you can <a class="el" href="defining_your_logger_filter.html">define them manually</a>:<ul>
<li>filters:<ul>
<li><code><a class="el" href="structboost_1_1logging_1_1filter_1_1no__ts.html" title="Manages is_enabled/set_enabled in a non-thread-safe way.">filter::no_ts</a></code> - single threaded <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a></li><li><code><a class="el" href="structboost_1_1logging_1_1filter_1_1ts.html" title="Thread-safe filter. Manages is_enabled/set_enabled in a thread-safe way.">filter::ts</a></code> - thread-safe <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a></li><li><code><a class="el" href="structboost_1_1logging_1_1filter_1_1use__tss__with__cache.html" title="Uses TSS (Thread Specific Storage) to find out if a filter is enabled or not.">filter::use_tss_with_cache</a></code> - use TSS: have each thread cache the value, and refresh at a given period</li><li><code><a class="el" href="structboost_1_1logging_1_1filter_1_1use__tss__once__init.html" title="Uses TSS (Thread Specific Storage) to find out if a filter is enabled or not. Once...">filter::use_tss_once_init</a></code> - use TSS: once the value is set, it will be used by each thread</li></ul>
</li><li>loggers:<ul>
<li><code>logger&lt;default_, default_, writer::threading::no_ts&gt; </code> - single threaded <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a></li><li><code>logger&lt;default_, default_, writer::threading::ts_write&gt; </code> - thread-safe <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a></li><li><code>logger&lt;default_, default_, writer::threading::on_dedicated_thread&gt; </code> - thread-safe <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a>, writing on dedicated thread</li></ul>
</li></ul>
<p>
<br>
 Note: I recommend defining loggers manually only if you know the lib very well. Otherwise, choose one of these:<ul>
<li><a class="el" href="namespaceboost_1_1logging_1_1scenario_1_1usage.html">customize the lib to suit your application's needs</a></li><li><a class="el" href="defining_your_logger_filter.html">Declaring/Defining your logger/filter class(es)</a> </li></ul>
<hr>
<br>
<small> Copyright <a href="http://www.torjo.com">John Torjo</a> &copy; 2007
</small> <br>

<small> Have a question/ suggestion/ comment? Send me <a href="http://www.torjo.com/contact.html">feedback</a>
</small> 

</body>
</html>
