<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Boost Logging Library v2: Class List</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li class="current"><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>Boost Logging Library v2 Class List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1after__being__destroyed__defer__to__function.html">boost::logging::after_being_destroyed_defer_to_function&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1filter___1_1change_1_1always__accurate.html">boost::logging::scenario::usage::filter_::change::always_accurate</a></td><td class="indexvalue">This is always accurate. However, it's the slowest too </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1logger___1_1change_1_1always__accurate.html">boost::logging::scenario::usage::logger_::change::always_accurate</a></td><td class="indexvalue">This is always accurate. However, it's the slowest too </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1filter_1_1always__disabled.html">boost::logging::filter::always_disabled</a></td><td class="indexvalue">Filter that is always disabled </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1filter_1_1always__enabled.html">boost::logging::filter::always_enabled</a></td><td class="indexvalue">Filter that is always enabled </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1append__newline__if__needed__t.html">boost::logging::formatter::append_newline_if_needed_t&lt; convert &gt;</a></td><td class="indexvalue">Appends a new line, if not already there </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1append__newline__t.html">boost::logging::formatter::append_newline_t&lt; convert &gt;</a></td><td class="indexvalue">Appends a new line </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1manipulator_1_1base.html">boost::logging::manipulator::base&lt; raw_param_type, param_type, ptr_type_ &gt;</a></td><td class="indexvalue">What to use as <a class="el" href="structboost_1_1logging_1_1manipulator_1_1base.html" title="What to use as base class, for your manipulator classes.">base</a> class, for your <a class="el" href="namespaceboost_1_1logging_1_1manipulator.html" title="Manipulators = Formatters and/or destinations.">manipulator</a> classes </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1base.html">boost::logging::formatter::base&lt; arg_type, ptr_type_ &gt;</a></td><td class="indexvalue">What to use as <a class="el" href="structboost_1_1logging_1_1formatter_1_1base.html" title="What to use as base class, for your formatter classes.">base</a> class, for your <a class="el" href="namespaceboost_1_1logging_1_1formatter.html" title="Formatter is a manipulator. It allows you to format the message before writing it...">formatter</a> classes </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1destination_1_1base.html">boost::logging::destination::base&lt; arg_type, ptr_type_ &gt;</a></td><td class="indexvalue">What to use as <a class="el" href="structboost_1_1logging_1_1destination_1_1base.html" title="What to use as base class, for your destination classes.">base</a> class, for your <a class="el" href="namespaceboost_1_1logging_1_1destination.html" title="Destination is a manipulator. It contains a place where the message, after being...">destination</a> classes </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1optimize_1_1cache__string__one__str.html">boost::logging::optimize::cache_string_one_str&lt; string_type_ &gt;</a></td><td class="indexvalue">Optimizes the formatting for prepending and/or appending strings to the original message </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1optimize_1_1cache__string__several__str.html">boost::logging::optimize::cache_string_several_str&lt; string_type_, ptr_type &gt;</a></td><td class="indexvalue">This holds 3 strings - one for prepend, one for modification, and one for appending </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1destination_1_1cerr__t.html">boost::logging::destination::cerr_t&lt; convert_dest &gt;</a></td><td class="indexvalue">Writes the string to cerr </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1manipulator_1_1class__.html">boost::logging::manipulator::class_&lt; type, op_e, base_type &gt;</a></td><td class="indexvalue">Use this when implementing your own <a class="el" href="namespaceboost_1_1logging_1_1formatter.html" title="Formatter is a manipulator. It allows you to format the message before writing it...">formatter</a> or <a class="el" href="namespaceboost_1_1logging_1_1destination.html" title="Destination is a manipulator. It contains a place where the message, after being...">destination</a> class. Don't use this directly. Use <a class="el" href="structboost_1_1logging_1_1formatter_1_1class__.html" title="Use this when implementing your own formatter class.">formatter::class_</a> or <a class="el" href="structboost_1_1logging_1_1destination_1_1class__.html" title="Use this when implementing your own destination class.">destination::class_</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1class__.html">boost::logging::formatter::class_&lt; type, op_e, base_type &gt;</a></td><td class="indexvalue">Use this when implementing your own <a class="el" href="namespaceboost_1_1logging_1_1formatter.html" title="Formatter is a manipulator. It allows you to format the message before writing it...">formatter</a> class </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1destination_1_1class__.html">boost::logging::destination::class_&lt; type, op_e, base_type &gt;</a></td><td class="indexvalue">Use this when implementing your own <a class="el" href="namespaceboost_1_1logging_1_1destination.html" title="Destination is a manipulator. It contains a place where the message, after being...">destination</a> class </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1profile_1_1compute.html">boost::logging::profile::compute</a></td><td class="indexvalue">Computes profiling information, and can show it to the user </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1profile_1_1compute__filter.html">boost::logging::profile::compute_filter&lt; filter_msg &gt;</a></td><td class="indexvalue">Profiles a <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a>. Don't use directly, use <a class="el" href="structboost_1_1logging_1_1profile_1_1compute__for__filter.html" title="Allows you to compute profiling for your filter class.">compute_for_filter</a> instead </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1profile_1_1compute__for__filter.html">boost::logging::profile::compute_for_filter&lt; filter_type &gt;</a></td><td class="indexvalue">Allows you to <a class="el" href="structboost_1_1logging_1_1profile_1_1compute.html" title="Computes profiling information, and can show it to the user.">compute</a> profiling for your <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> class </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1profile_1_1compute__for__logger.html">boost::logging::profile::compute_for_logger&lt; logger_type &gt;</a></td><td class="indexvalue">Allows you to <a class="el" href="structboost_1_1logging_1_1profile_1_1compute.html" title="Computes profiling information, and can show it to the user.">compute</a> profiling for your <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> class </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1logger___1_1favor_1_1correctness.html">boost::logging::scenario::usage::logger_::favor::correctness</a></td><td class="indexvalue">All messages will be logged. This is the default for multi-threaded application </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1destination_1_1cout__t.html">boost::logging::destination::cout_t&lt; convert_dest &gt;</a></td><td class="indexvalue">Writes the string to console </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1logger___1_1gather_1_1custom.html">boost::logging::scenario::usage::logger_::gather::custom&lt; gather_type &gt;</a></td><td class="indexvalue">If you want to <a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1use.html" title="Finds a filter class and a logger class that fit your application&#39;s needs.">use</a> your <a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1logger___1_1gather_1_1custom.html" title="If you want to use your custom class, specify it here.">custom</a> class, specify it here </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1destination_1_1dbg__window__t.html">boost::logging::destination::dbg_window_t&lt; convert_dest &gt;</a></td><td class="indexvalue">Writes the string to output debug window </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1filter_1_1debug__enabled.html">boost::logging::filter::debug_enabled</a></td><td class="indexvalue">Filter that is enabled in debug mode </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1detail_1_1default__cache__keeper.html">boost::logging::detail::default_cache_keeper&lt; cache_type &gt;</a></td><td class="indexvalue">Default implementation of keeping cache </td></tr>
  <tr><td class="indexkey"><a class="el" href="structdir__spec.html">dir_spec</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1dump__default__levels.html">boost::logging::dump_default_levels</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1dump__level.html">boost::logging::dump_level&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1ensure__early__log__creation.html">boost::logging::ensure_early_log_creation</a></td><td class="indexvalue">Ensures the log is created before main(), even if not used before main </td></tr>
  <tr><td class="indexkey"><a class="el" href="structextensions.html">extensions</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1tag_1_1file__line.html">boost::logging::tag::file_line</a></td><td class="indexvalue">Tag that holds file/line context information </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1tag_1_1file__line__t.html">boost::logging::formatter::tag::file_line_t&lt; convert &gt;</a></td><td class="indexvalue">Dumps file/line information (corresponds to <a class="el" href="structboost_1_1logging_1_1tag_1_1file__line.html" title="tag that holds file/line context information">boost::logging::tag::file_line</a> <a class="el" href="namespaceboost_1_1logging_1_1formatter_1_1tag.html" title="Classes that process the tags coming with the library.">tag</a> class) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1destination_1_1file__settings.html">boost::logging::destination::file_settings</a></td><td class="indexvalue">Settings for when constructing a file class. To see how it's used, see <a class="el" href="dealing_with_flags.html">Dealing with flags.</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structfile__statistics.html">file_statistics</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1destination_1_1file__t.html">boost::logging::destination::file_t&lt; convert_dest &gt;</a></td><td class="indexvalue">Writes the string to a file </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1ts_1_1filter__.html">boost::logging::scenario::ts::filter_</a></td><td class="indexvalue">Filter thread-safety </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1detail_1_1flag.html">boost::logging::detail::flag&lt; self_type &gt;</a></td><td class="indexvalue">Can hold a <a class="el" href="structboost_1_1logging_1_1detail_1_1flag.html" title="Can hold a flag. See dealing_with_flags.">flag</a>. See dealing_with_flags </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1writer_1_1format__write.html">boost::logging::writer::format_write&lt; formatter_base, destination_base, lock_resource, apply_format_and_write, router_type, formatter_array, destination_array &gt;</a></td><td class="indexvalue">Allows custom formatting of the message before logging it, and writing it to several destinations </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1msg__route_1_1formatter__and__destination__array__holder.html">boost::logging::msg_route::formatter_and_destination_array_holder&lt; formatter_array, destination_array &gt;</a></td><td class="indexvalue">Recomended base class for message routers that need access to the underlying <a class="el" href="namespaceboost_1_1logging_1_1formatter.html" title="Formatter is a manipulator. It allows you to format the message before writing it...">formatter</a> and/or <a class="el" href="namespaceboost_1_1logging_1_1destination.html" title="Destination is a manipulator. It contains a place where the message, after being...">destination</a> array </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1forward__to__logger.html">boost::logging::forward_to_logger&lt; gather_msg, write_msg &gt;</a></td><td class="indexvalue">Forwards everything to a different <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1tag_1_1function.html">boost::logging::tag::function</a></td><td class="indexvalue">Tag that holds <a class="el" href="structboost_1_1logging_1_1tag_1_1function.html" title="tag that holds function name context information">function</a> name context information </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1tag_1_1function__t.html">boost::logging::formatter::tag::function_t&lt; convert &gt;</a></td><td class="indexvalue">Dumps function name information (corresponds to <a class="el" href="structboost_1_1logging_1_1tag_1_1function.html" title="tag that holds function name context information">boost::logging::tag::function</a> <a class="el" href="namespaceboost_1_1logging_1_1formatter_1_1tag.html" title="Classes that process the tags coming with the library.">tag</a> class) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1tag_1_1high__precision__time.html">boost::logging::tag::high_precision_time</a></td><td class="indexvalue">Tag that holds the current <a class="el" href="structboost_1_1logging_1_1tag_1_1time.html" title="tag that holds the current time context information">time</a> (with high precision) context information </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1tag_1_1high__precision__time__t.html">boost::logging::formatter::tag::high_precision_time_t&lt; convert &gt;</a></td><td class="indexvalue">Dumps current high_precision_time information (corresponds to <a class="el" href="structboost_1_1logging_1_1tag_1_1high__precision__time.html" title="tag that holds the current time (with high precision) context information">boost::logging::tag::high_precision_time</a> <a class="el" href="namespaceboost_1_1logging_1_1formatter_1_1tag.html" title="Classes that process the tags coming with the library.">tag</a> class) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1high__precision__time__t.html">boost::logging::formatter::high_precision_time_t&lt; convert &gt;</a></td><td class="indexvalue">Prefixes the message with a high-precision time (. You pass the format string at construction </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1tag_1_1holder.html">boost::logging::tag::holder&lt; string_, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10 &gt;</a></td><td class="indexvalue">Holds up to 10 <a class="el" href="namespaceboost_1_1logging_1_1tag.html">tags</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1level_1_1holder__compile__time.html">boost::logging::level::holder_compile_time&lt; fix_level &gt;</a></td><td class="indexvalue">Filter - holds the <a class="el" href="namespaceboost_1_1logging_1_1level.html" title="Handling levels - classes that can hold and/or deal with levels - filters and level...">level</a> - and tells you at compile time if a <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> is enabled or not </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1level_1_1holder__no__ts.html">boost::logging::level::holder_no_ts</a></td><td class="indexvalue">Filter - holds the <a class="el" href="namespaceboost_1_1logging_1_1level.html" title="Handling levels - classes that can hold and/or deal with levels - filters and level...">level</a>, in a non-thread-safe way </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1level_1_1holder__ts.html">boost::logging::level::holder_ts</a></td><td class="indexvalue">Filter - holds the <a class="el" href="namespaceboost_1_1logging_1_1level.html" title="Handling levels - classes that can hold and/or deal with levels - filters and level...">level</a>, in a thread-safe way </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1level_1_1holder__tss__with__cache.html">boost::logging::level::holder_tss_with_cache&lt; default_cache_secs &gt;</a></td><td class="indexvalue">Filter - holds the <a class="el" href="namespaceboost_1_1logging_1_1level.html" title="Handling levels - classes that can hold and/or deal with levels - filters and level...">level</a>, in a thread-safe way, using TLS </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1idx__t.html">boost::logging::formatter::idx_t&lt; convert &gt;</a></td><td class="indexvalue">Prefixes each message with an index </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1implement__default__logger.html">boost::logging::implement_default_logger&lt; gather_msg, write_msg &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1manipulator_1_1implement__op__equal.html">boost::logging::manipulator::implement_op_equal</a></td><td class="indexvalue">When you implement your <a class="el" href="namespaceboost_1_1logging_1_1manipulator.html" title="Manipulators = Formatters and/or destinations.">manipulator</a> class, how is operator== to be implemented? </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1manipulator_1_1is__generic.html">boost::logging::manipulator::is_generic</a></td><td class="indexvalue">Represents a generic <a class="el" href="namespaceboost_1_1logging_1_1manipulator.html" title="Manipulators = Formatters and/or destinations.">manipulator</a> (<a class="el" href="namespaceboost_1_1logging_1_1formatter.html" title="Formatter is a manipulator. It allows you to format the message before writing it...">formatter</a> or <a class="el" href="namespaceboost_1_1logging_1_1destination.html" title="Destination is a manipulator. It contains a place where the message, after being...">destination</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1tag_1_1level.html">boost::logging::tag::level</a></td><td class="indexvalue">Tag that holds the log <a class="el" href="structboost_1_1logging_1_1tag_1_1level.html" title="tag that holds the log level context information">level</a> context information </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1ts_1_1level__.html">boost::logging::scenario::ts::level_</a></td><td class="indexvalue">Filter uses levels? </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1tag_1_1level__t.html">boost::logging::formatter::tag::level_t&lt; convert &gt;</a></td><td class="indexvalue">Dumps <a class="el" href="namespaceboost_1_1logging_1_1level.html" title="Handling levels - classes that can hold and/or deal with levels - filters and level...">level</a> (corresponds to <a class="el" href="structboost_1_1logging_1_1tag_1_1level.html" title="tag that holds the log level context information">boost::logging::tag::level</a> <a class="el" href="namespaceboost_1_1logging_1_1formatter_1_1tag.html" title="Classes that process the tags coming with the library.">tag</a> class) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1logger.html">boost::logging::logger&lt; gather_msg, write_msg &gt;</a></td><td class="indexvalue">The <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> class. Every log from your application is an instance of this (see <a class="el" href="workflow.html#workflow_processing">workflow</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1ts_1_1logger__.html">boost::logging::scenario::ts::logger_</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1logger__base.html">boost::logging::logger_base&lt; gather_msg, write_msg, dummy &gt;</a></td><td class="indexvalue">Logger base class </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1logger__format__write.html">boost::logging::logger_format_write&lt; format_base, destination_base, thread_safety, gather, lock_resource &gt;</a></td><td class="indexvalue">Makes it easier to use a <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> with format_write class </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1logger__holder.html">boost::logging::logger_holder&lt; type &gt;</a></td><td class="indexvalue">Allows using a log without knowing its full type yet. Even if the log is not fully <b>defined</b>, you can still use it </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1logger__holder__by__ptr.html">boost::logging::logger_holder_by_ptr&lt; type &gt;</a></td><td class="indexvalue">Allows using a log without knowing its full type yet. Even if the log is not fully <b>defined</b>, you can still use it </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1logger__holder__by__value.html">boost::logging::logger_holder_by_value&lt; type &gt;</a></td><td class="indexvalue">Allows using a log without knowing its full type yet. Even if the log is not fully <b>defined</b>, you can still use it </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1logger__to__gather.html">boost::logging::logger_to_gather&lt;&gt;</a></td><td class="indexvalue">Given a <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> class, finds its gather_msg , without needing to know the logger's definition (a typedef is enough) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1profile_1_1logger__to__write.html">boost::logging::profile::logger_to_write&lt;&gt;</a></td><td class="indexvalue">Given the <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> type, gets the write_msg part, without needing to know the logger's definition (a typedef is enough) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1tag_1_1module.html">boost::logging::tag::module</a></td><td class="indexvalue">Tag that holds <a class="el" href="structboost_1_1logging_1_1tag_1_1module.html" title="tag that holds module context information (note: you need to specify the module yourself)...">module</a> context information (note: you need to specify the <a class="el" href="structboost_1_1logging_1_1tag_1_1module.html" title="tag that holds module context information (note: you need to specify the module yourself)...">module</a> yourself) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1tag_1_1module__t.html">boost::logging::formatter::tag::module_t&lt; convert &gt;</a></td><td class="indexvalue">Dumps module information (corresponds to <a class="el" href="structboost_1_1logging_1_1tag_1_1module.html" title="tag that holds module context information (note: you need to specify the module yourself)...">boost::logging::tag::module</a> <a class="el" href="namespaceboost_1_1logging_1_1formatter_1_1tag.html" title="Classes that process the tags coming with the library.">tag</a> class) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1msg__type.html">boost::logging::formatter::msg_type&lt; T &gt;</a></td><td class="indexvalue">What is the default type of your string, in formatter_base ? See BOOST_LOG_FORMAT_MSG </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1destination_1_1msg__type.html">boost::logging::destination::msg_type&lt; T &gt;</a></td><td class="indexvalue">What is the default type of your string, in destination_base ? See BOOST_LOG_DESTINATION_MSG </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1named__logger.html">boost::logging::named_logger&lt; gather &gt;</a></td><td class="indexvalue">Named_logger&lt;...&gt;type finds a <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> that uses <a class="el" href="structboost_1_1logging_1_1writer_1_1named__write.html">writer::named_write</a>&lt;&gt; "Named Formatters and Destinations" </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1named__spacer__t.html">boost::logging::formatter::named_spacer_t&lt; convert, format_base, lock_resource &gt;</a></td><td class="indexvalue">Allows you to contain multiple formatters, and specify a spacer between them. You have a spacer string, and within it, you can escape your contained formatters </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1destination_1_1named__t.html">boost::logging::destination::named_t&lt; destination_base, lock_resource &gt;</a></td><td class="indexvalue">Allows you to contain multiple destinations, give each such <a class="el" href="namespaceboost_1_1logging_1_1destination.html" title="Destination is a manipulator. It contains a place where the message, after being...">destination</a> a name. Then, at run-time, you can specify a format string which will specify which destinations to be called, and on what order </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1writer_1_1named__write.html">boost::logging::writer::named_write&lt; format_write_ &gt;</a></td><td class="indexvalue">Composed of a named <a class="el" href="namespaceboost_1_1logging_1_1formatter.html" title="Formatter is a manipulator. It allows you to format the message before writing it...">formatter</a> and a named destinations. Thus, you can specify the formatting and destinations as strings </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1filter___1_1level_1_1no__levels.html">boost::logging::scenario::usage::filter_::level::no_levels</a></td><td class="indexvalue">Not using levels (default) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1filter_1_1no__ts.html">boost::logging::filter::no_ts</a></td><td class="indexvalue">Manages is_enabled/set_enabled in a non-thread-safe way </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1writer_1_1threading_1_1no__ts.html">boost::logging::writer::threading::no_ts</a></td><td class="indexvalue">Not thread-safe </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1manipulator_1_1non__const__context.html">boost::logging::manipulator::non_const_context&lt; context_type &gt;</a></td><td class="indexvalue">In case your <a class="el" href="namespaceboost_1_1logging_1_1manipulator.html" title="Manipulators = Formatters and/or destinations.">manipulator</a> (<a class="el" href="namespaceboost_1_1logging_1_1formatter.html" title="Formatter is a manipulator. It allows you to format the message before writing it...">formatter</a> or <a class="el" href="namespaceboost_1_1logging_1_1destination.html" title="Destination is a manipulator. It contains a place where the message, after being...">destination</a>) needs to hold non-const context information, it can to derive from this. This automatically creates a shared pointer to the context information </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1filter___1_1change_1_1often.html">boost::logging::scenario::usage::filter_::change::often&lt; cache_period_secs &gt;</a></td><td class="indexvalue">Optimize for often change. Does per-thread caching. At a given period, it re-synchronizes </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1logger___1_1change_1_1often.html">boost::logging::scenario::usage::logger_::change::often&lt; cache_period_secs &gt;</a></td><td class="indexvalue">Optimize for <a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1logger___1_1change_1_1often.html" title="Optimize for often change. Does per-thread caching. At a given period, it re-synchronizes...">often</a> <a class="el" href="namespaceboost_1_1logging_1_1scenario_1_1usage_1_1logger___1_1change.html" title="When does the logger change, that is, how often do you manipulate it?">change</a>. Does per-thread caching. At a given period, it re-synchronizes. This is the default, for multi-threaded applications </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1writer_1_1on__dedicated__thread.html">boost::logging::writer::on_dedicated_thread&lt; msg_type, base_type &gt;</a></td><td class="indexvalue">Performs all writes on a dedicated thread - very efficient and <b>thread-safe</b> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1writer_1_1threading_1_1on__dedicated__thread.html">boost::logging::writer::threading::on_dedicated_thread</a></td><td class="indexvalue">Thread-safe write on a dedicated thread. Very efficient. Formatting &amp; writing to destinations happens on the dedicated thread </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1logger___1_1gather_1_1ostream__like.html">boost::logging::scenario::usage::logger_::gather::ostream_like</a></td><td class="indexvalue">Using the cool operator&lt;&lt; (default) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1gather_1_1out__base.html">boost::logging::gather::out_base</a></td><td class="indexvalue">In case your <a class="el" href="namespaceboost_1_1logging_1_1gather.html" title="Classes that implement gathering the message.">gather</a> class returns anything else than a std::basic_ostream, that returned class <b>must</b> derive from this </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1filter_1_1release__enabled.html">boost::logging::filter::release_enabled</a></td><td class="indexvalue">Filter that is enabled in release mode </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1gather_1_1ostream__like_1_1return__raw__stream.html">boost::logging::gather::ostream_like::return_raw_stream&lt; stream_type &gt;</a></td><td class="indexvalue">Allows you to write to a log using the cool "&lt;&lt;" operator. The <code></code>.<a class="el" href="structboost_1_1logging_1_1gather_1_1ostream__like_1_1return__raw__stream.html#da922a9ae46b17cc77111135ad52c7e8">msg()</a> returns the stream itself </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1gather_1_1ostream__like_1_1return__str.html">boost::logging::gather::ostream_like::return_str&lt; string, stream_type &gt;</a></td><td class="indexvalue">Allows you to write to a log using the cool "&lt;&lt;" operator. The .<a class="el" href="structboost_1_1logging_1_1gather_1_1ostream__like_1_1return__str.html#d3d80a5ce74d29a9f56eb6d96005688f" title="returns a string">msg()</a> returns a string - whatever you set as first template param </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1gather_1_1ostream__like_1_1return__tag__holder.html">boost::logging::gather::ostream_like::return_tag_holder&lt; holder_type, stream_type &gt;</a></td><td class="indexvalue">Returns a <a class="el" href="namespaceboost_1_1logging_1_1tag.html" title="Allows you to use tags (extra information about the context of the logged message:...">tag</a> holder </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1destination_1_1rolling__file__settings.html">boost::logging::destination::rolling_file_settings</a></td><td class="indexvalue">Settings you can pass to the rolling file. To see how it's used, see <a class="el" href="dealing_with_flags.html">Dealing with flags.</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1destination_1_1rolling__file__t.html">boost::logging::destination::rolling_file_t&lt; convert_dest &gt;</a></td><td class="indexvalue">Writes to multiple files: name_prefix.1, name_prefix.2, ... name_prefix.N, and then restarts from 1 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1op__equal_1_1same__type__op__equal.html">boost::logging::op_equal::same_type_op_equal&lt; type &gt;</a></td><td class="indexvalue">Implements operator==, which compares two objects. If they have the same type, it will compare them using the type's member operator== </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1op__equal_1_1same__type__op__equal__base.html">boost::logging::op_equal::same_type_op_equal_base</a></td><td class="indexvalue">Base class when you want to implement operator== that will compare based on type and member operator== </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1detail_1_1scoped__logger.html">boost::logging::detail::scoped_logger&lt; ostream_type, gather_msg &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1logger___1_1change_1_1set__once__when__multiple__threads.html">boost::logging::scenario::usage::logger_::change::set_once_when_multiple_threads</a></td><td class="indexvalue">Set only once, when there could be multiple thread running </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1filter___1_1change_1_1set__once__when__multiple__threads.html">boost::logging::scenario::usage::filter_::change::set_once_when_multiple_threads</a></td><td class="indexvalue">Set only once, when there could be multiple thread running </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1logger___1_1change_1_1set__once__when__one__thread.html">boost::logging::scenario::usage::logger_::change::set_once_when_one_thread</a></td><td class="indexvalue">Set only once, when there's only one thread running - thus, you don't need to worry about thread-syncronizing </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1filter___1_1change_1_1set__once__when__one__thread.html">boost::logging::scenario::usage::filter_::change::set_once_when_one_thread</a></td><td class="indexvalue">Set only once, when there's only one thread running - thus, you don't need to worry about thread-syncronizing </td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1logging_1_1array_1_1shared__ptr__holder.html">boost::logging::array::shared_ptr_holder&lt; base_type, mutex &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1msg__route_1_1simple.html">boost::logging::msg_route::simple&lt; formatter_base, destination_base, lock_resource &gt;</a></td><td class="indexvalue">Represents a <a class="el" href="structboost_1_1logging_1_1msg__route_1_1simple.html" title="Represents a simple router - first calls all formatters - in the order they were...">simple</a> router - first calls all formatters - in the order they were added, then all destinations - in the order they were added </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1format__and__write_1_1simple.html">boost::logging::format_and_write::simple&lt; msg_type &gt;</a></td><td class="indexvalue">Formats the message, and writes it to destinations - calls <code>operator()</code> on the formatters , and <code>operator()</code> on the destinations. Ignores <code>clear_format()</code> commands </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1format__and__write_1_1simple__care__for__clear__format.html">boost::logging::format_and_write::simple_care_for_clear_format&lt; msg_type, string_type &gt;</a></td><td class="indexvalue">Formats the message, and writes it to destinations - calls <code>operator()</code> on the formatters , and <code>operator()</code> on the destinations </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1filter___1_1change_1_1single__thread.html">boost::logging::scenario::usage::filter_::change::single_thread</a></td><td class="indexvalue">Single threading. It doesn't matter when/how often the filter/logger changes </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1lock__resource__finder_1_1single__thread.html">boost::logging::lock_resource_finder::single_thread</a></td><td class="indexvalue">Does not lock the resouce at read/write access </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1logger___1_1change_1_1single__thread.html">boost::logging::scenario::usage::logger_::change::single_thread</a></td><td class="indexvalue">Single threading. It doesn't matter when/how <a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1logger___1_1change_1_1often.html" title="Optimize for often change. Does per-thread caching. At a given period, it re-synchronizes...">often</a> the filter/logger changes. This is the default, for single-threaded applications </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1logger___1_1favor_1_1single__thread.html">boost::logging::scenario::usage::logger_::favor::single_thread</a></td><td class="indexvalue">Single threading. It doesn't matter when/how often the filter/logger changes. This is the default, for single-threaded applications </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1spacer__t.html">boost::logging::formatter::spacer_t&lt; convert, original_formatter, is_generic_formatter &gt;</a></td><td class="indexvalue">Prepends some info, and appends some info to an existing <a class="el" href="namespaceboost_1_1logging_1_1formatter.html" title="Formatter is a manipulator. It allows you to format the message before writing it...">formatter</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1logger___1_1favor_1_1speed.html">boost::logging::scenario::usage::logger_::favor::speed</a></td><td class="indexvalue">This will <a class="el" href="namespaceboost_1_1logging_1_1scenario_1_1usage_1_1logger___1_1favor.html" title="When logging, what should we favor?">favor</a> <a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1logger___1_1favor_1_1speed.html" title="This will favor speed (logging will happen on a dedicated thread). The only problem...">speed</a> (<a class="el" href="namespaceboost_1_1logging.html" title="Root namespace. All the logging lib is contained in this namespace, or sub-namespaces...">logging</a> will happen on a dedicated thread). The only problem you could have is if the application crashes </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1destination_1_1stream__t.html">boost::logging::destination::stream_t&lt; convert_dest &gt;</a></td><td class="indexvalue">Writes to stream </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1tag_1_1thread__id.html">boost::logging::tag::thread_id</a></td><td class="indexvalue">Tag that holds thread id context information </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1thread__id__t.html">boost::logging::formatter::thread_id_t&lt; convert &gt;</a></td><td class="indexvalue">Writes the thread_id to the log </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1tag_1_1thread__id__t.html">boost::logging::formatter::tag::thread_id_t&lt; stream_type, convert &gt;</a></td><td class="indexvalue">Dumps thread id information (corresponds to <a class="el" href="structboost_1_1logging_1_1tag_1_1thread__id.html" title="tag that holds thread id context information">boost::logging::tag::thread_id</a> <a class="el" href="namespaceboost_1_1logging_1_1formatter_1_1tag.html" title="Classes that process the tags coming with the library.">tag</a> class) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1tag_1_1time.html">boost::logging::tag::time</a></td><td class="indexvalue">Tag that holds the current <a class="el" href="structboost_1_1logging_1_1tag_1_1time.html" title="tag that holds the current time context information">time</a> context information </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1detail_1_1time__format__holder.html">boost::logging::detail::time_format_holder</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1time__strf__t.html">boost::logging::formatter::time_strf_t&lt; convert &gt;</a></td><td class="indexvalue">Prefixes the message with the time, by using strftime function. You pass the format string at construction </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1time__t.html">boost::logging::formatter::time_t&lt; convert &gt;</a></td><td class="indexvalue">Prefixes the message with the time. You pass the format string at construction </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1tag_1_1time__t.html">boost::logging::formatter::tag::time_t&lt; convert &gt;</a></td><td class="indexvalue">Dumps current time information (corresponds to <a class="el" href="structboost_1_1logging_1_1tag_1_1time.html" title="tag that holds the current time context information">boost::logging::tag::time</a> <a class="el" href="namespaceboost_1_1logging_1_1formatter_1_1tag.html" title="Classes that process the tags coming with the library.">tag</a> class) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1detail_1_1to__override.html">boost::logging::detail::to_override&lt;&gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1lock__resource__finder_1_1ts.html">boost::logging::lock_resource_finder::ts&lt; mutex &gt;</a></td><td class="indexvalue">Locks a resource thread-safe - each time, at read/write (safe but rather inefficient) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1filter_1_1ts.html">boost::logging::filter::ts</a></td><td class="indexvalue">Thread-safe <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a>. Manages is_enabled/set_enabled in a thread-safe way </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1locker_1_1ts__resource.html">boost::logging::locker::ts_resource&lt; type, mutex &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1writer_1_1ts__write.html">boost::logging::writer::ts_write&lt; base_type &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1writer_1_1threading_1_1ts__write.html">boost::logging::writer::threading::ts_write</a></td><td class="indexvalue">Thread-safe write. All writes are protected by a lock </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1lock__resource__finder_1_1tss__once__init.html">boost::logging::lock_resource_finder::tss_once_init&lt; mutex &gt;</a></td><td class="indexvalue">Allows you to initialize this resource once even if multiple threads are running. Then, all threads will use the initialized value </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1tss__ostringstream.html">boost::logging::tss_ostringstream&lt; stream &gt;</a></td><td class="indexvalue">Represents an ostringstream that takes advantage of TSS (Thread Specific Storage). In other words, each thread has its own copy of an ostringstream, thus when needed, we avoid the cost of re-creating it (it's created only once per thread) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1locker_1_1tss__resource__once__init.html">boost::logging::locker::tss_resource_once_init&lt; type, mutex &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1locker_1_1tss__resource__with__cache.html">boost::logging::locker::tss_resource_with_cache&lt; type, default_cache_secs, mutex &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1lock__resource__finder_1_1tss__with__cache.html">boost::logging::lock_resource_finder::tss_with_cache&lt; refresh_secs, mutex &gt;</a></td><td class="indexvalue">Caches the resource on each thread, and refreshes it at <code>refresh_secs</code> period </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1use.html">boost::logging::scenario::usage::use&lt; filter_change, filter_level, logger_change, logger_favor, logger_gather &gt;</a></td><td class="indexvalue">Finds a <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> class and a <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> class that fit your application's needs </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1ts_1_1use.html">boost::logging::scenario::ts::use&lt; filter_type, level_type, logger_type &gt;</a></td><td class="indexvalue">Find the right <a class="el" href="structboost_1_1logging_1_1logger.html" title="The logger class. Every log from your application is an instance of this (see workflow)...">logger</a> and <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a>, based on thread-safety: <a class="el" href="structboost_1_1logging_1_1scenario_1_1ts_1_1filter__.html#270f9789ce42edc6337854e2894896e9" title="type of filter thread-safety">filter_::type</a>, <a class="el" href="structboost_1_1logging_1_1scenario_1_1ts_1_1level__.html#583ba4a6da1e55a72f87bd03c2ea7d25" title="type of filter levels usage">level_::type</a> and <a class="el" href="structboost_1_1logging_1_1scenario_1_1ts_1_1logger__.html#c6589fa34efa8d8fea1354277fde770f" title="type of logger thread-safety">logger_::type</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1format__and__write_1_1use__cache.html">boost::logging::format_and_write::use_cache&lt; formatter_base, destination_base, msg_type &gt;</a></td><td class="indexvalue">This uses a cache, when calling formatters/destinations - for writing a given message </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1scenario_1_1usage_1_1filter___1_1level_1_1use__levels.html">boost::logging::scenario::usage::filter_::level::use_levels</a></td><td class="indexvalue">Using levels </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1filter_1_1use__tss__once__init.html">boost::logging::filter::use_tss_once_init</a></td><td class="indexvalue">Uses TSS (Thread Specific Storage) to find out if a <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> is enabled or not. Once the <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> is initialized to a value, that value will always be used </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1filter_1_1use__tss__with__cache.html">boost::logging::filter::use_tss_with_cache&lt; default_cache_secs &gt;</a></td><td class="indexvalue">Uses TSS (Thread Specific Storage) to find out if a <a class="el" href="namespaceboost_1_1logging_1_1filter.html" title="Contains filter implementations. A filter tells the logger if it&#39;s enabled or...">filter</a> is enabled or not </td></tr>
  <tr><td class="indexkey"><a class="el" href="structboost_1_1logging_1_1formatter_1_1uses__tag.html">boost::logging::formatter::uses_tag&lt; type, tag_type &gt;</a></td><td class="indexvalue">Specifies that a <a class="el" href="namespaceboost_1_1logging_1_1formatter.html" title="Formatter is a manipulator. It allows you to format the message before writing it...">formatter</a> class handles a certain <a class="el" href="namespaceboost_1_1logging_1_1formatter_1_1tag.html" title="Classes that process the tags coming with the library.">tag</a> class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1logging_1_1msg__route_1_1with__route.html">boost::logging::msg_route::with_route&lt; formatter_base, destination_base, lock_resource, formatter_array, destination_array &gt;</a></td><td class="indexvalue">. Represents a router - by default, first calls all formatters, then all destinations. However you can overwrite this <a class="el" href="classboost_1_1logging_1_1msg__route_1_1with__route_1_1route.html">route</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1logging_1_1msg__route_1_1with__route_1_1route.html">boost::logging::msg_route::with_route&lt; formatter_base, destination_base, lock_resource, formatter_array, destination_array &gt;::route</a></td><td class="indexvalue"></td></tr>
</table>
<hr>
<br>
<small> Copyright <a href="http://www.torjo.com">John Torjo</a> &copy; 2007
</small> <br>

<small> Have a question/ suggestion/ comment? Send me <a href="http://www.torjo.com/contact.html">feedback</a>
</small> 

</body>
</html>
